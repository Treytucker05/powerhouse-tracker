{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,Y,I,G,E,E,O,C,c,I,G,E,E,O,C,a,I,G,E,E,O,C,qB,I,G,E,E,O,C,mB,I,GCGC,IAAA,EAAA,EAAA,SAID,IAAI,EAAc,KACZ,EAAU,OAAO,IAAI,CAAC,AAAA,EAAA,OAAY,CAAE,eAAe,EAKzD,SAAS,IACP,IAAM,EAAS,SAAS,cAAc,CAAC,eACvC,GAAI,CAAC,EAEH,OADA,QAAQ,KAAK,CAAC,0BACP,KAGT,IAAM,EAAM,EAAO,UAAU,CAAC,MAC9B,GAAI,CAAC,EAEH,OADA,QAAQ,KAAK,CAAC,6BACP,KAGT,GAAI,AAAiB,aAAjB,OAAO,MAET,OADA,QAAQ,KAAK,CAAC,uBACP,KAGT,IAAM,EAAY,EAAQ,GAAG,CAAC,AAAA,GAAU,AAAA,EAAA,OAAY,CAAE,eAAe,CAAC,EAAO,EAAI,GAC3E,EAAmB,EAAQ,GAAG,CAAC,AAAA,GAAU,AAAA,EAAA,OAAY,CAAE,cAAc,CAAC,IAiF5E,OAhFE,EAAc,IAAI,MAAM,EAAK,CAC7B,KAAM,MACN,KAAM,CACJ,OAAQ,EACR,SAAU,CAAC,CACT,MAAO,eACP,KAAM,EACN,gBAAiB,EACjB,YAAa,EAAiB,GAAG,CAAC,AAAA,GAAS,EAAM,OAAO,CAAC,MAAO,MAChE,YAAa,CACf,EAAG,CACD,MAAO,MACP,KAAM,EAAQ,GAAG,CAAC,AAAA,GAAU,AAAA,EAAA,OAAY,CAAE,eAAe,CAAC,EAAO,CAAC,GAAG,EACrE,KAAM,OACN,YAAa,yBACb,gBAAiB,cACjB,YAAa,EACb,YAAa,EACb,qBAAsB,uBACtB,WAAY,CAAC,EAAG,EAAE,AA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","sources":["<anon>","js/ui/chartManager.js","js/core/trainingState.js","js/algorithms/volume.js","js/algorithms/effort.js","js/algorithms/fatigue.js","js/algorithms/validation.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire66c8\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire66c8\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"e8wst\", function(module, exports) {\n\n$parcel$export(module.exports, \"initChart\", () => $a4aafd93596a3fc7$export$88eaec01eecac0a4);\n$parcel$export(module.exports, \"updateChart\", () => $a4aafd93596a3fc7$export$f07c621b7d36d1ec);\n$parcel$export(module.exports, \"resetChart\", () => $a4aafd93596a3fc7$export$1be07204ac5fe8ce);\n$parcel$export(module.exports, \"addVolumeLandmarks\", () => $a4aafd93596a3fc7$export$d2cfe3709d2fae1f);\n$parcel$export(module.exports, \"exportChartImage\", () => $a4aafd93596a3fc7$export$f09d42cecf7f68cf);\n/**\r\n * Chart Management UI\r\n * Handles all chart rendering and interactions\r\n */ \nvar $gBc5V = parcelRequire(\"gBc5V\");\nlet $a4aafd93596a3fc7$export$c9f6e7e078edfb63 = null;\nconst $a4aafd93596a3fc7$var$muscles = Object.keys((0, $gBc5V.default).volumeLandmarks);\n/**\r\n * Initialize the weekly volume chart\r\n */ function $a4aafd93596a3fc7$export$88eaec01eecac0a4() {\n    const canvas = document.getElementById('weeklyChart');\n    if (!canvas) {\n        console.error('Chart canvas not found');\n        return null;\n    }\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Cannot get canvas context');\n        return null;\n    }\n    if (typeof Chart === 'undefined') {\n        console.error('Chart.js not loaded');\n        return null;\n    }\n    const chartData = $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).currentWeekSets[muscle] || 0);\n    const backgroundColors = $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).getVolumeColor(muscle));\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63 = new Chart(ctx, {\n        type: 'bar',\n        data: {\n            labels: $a4aafd93596a3fc7$var$muscles,\n            datasets: [\n                {\n                    label: 'Current Sets',\n                    data: chartData,\n                    backgroundColor: backgroundColors,\n                    borderColor: backgroundColors.map((color)=>color.replace('0.6', '1')),\n                    borderWidth: 2\n                },\n                {\n                    label: 'MEV',\n                    data: $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).volumeLandmarks[muscle].MEV),\n                    type: 'line',\n                    borderColor: 'rgba(255, 255, 0, 0.8)',\n                    backgroundColor: 'transparent',\n                    borderWidth: 2,\n                    pointRadius: 3,\n                    pointBackgroundColor: 'rgba(255, 255, 0, 1)',\n                    borderDash: [\n                        5,\n                        5\n                    ]\n                },\n                {\n                    label: 'MRV',\n                    data: $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).volumeLandmarks[muscle].MRV),\n                    type: 'line',\n                    borderColor: 'rgba(255, 0, 0, 0.8)',\n                    backgroundColor: 'transparent',\n                    borderWidth: 2,\n                    pointRadius: 3,\n                    pointBackgroundColor: 'rgba(255, 0, 0, 1)',\n                    borderDash: [\n                        10,\n                        5\n                    ]\n                }\n            ]\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: {\n                    labels: {\n                        color: '#fff'\n                    }\n                },\n                tooltip: {\n                    callbacks: {\n                        afterLabel: function(context) {\n                            const muscle = context.label;\n                            const sets = context.parsed.y;\n                            const landmarks = (0, $gBc5V.default).volumeLandmarks[muscle];\n                            const status = (0, $gBc5V.default).getVolumeStatus(muscle, sets);\n                            return [\n                                `Status: ${status}`,\n                                `MEV: ${landmarks.MEV} | MRV: ${landmarks.MRV}`,\n                                `Target RIR: ${(0, $gBc5V.default).getTargetRIR()}`\n                            ];\n                        }\n                    }\n                }\n            },\n            scales: {\n                y: {\n                    beginAtZero: true,\n                    grid: {\n                        color: 'rgba(255, 255, 255, 0.1)'\n                    },\n                    ticks: {\n                        color: '#fff',\n                        stepSize: 5 // Show every 5 sets on Y-axis\n                    }\n                },\n                x: {\n                    grid: {\n                        color: 'rgba(255, 255, 255, 0.1)'\n                    },\n                    ticks: {\n                        color: '#fff'\n                    }\n                }\n            }\n        }\n    });\n    return $a4aafd93596a3fc7$export$c9f6e7e078edfb63;\n}\n/**\r\n * Update chart with current data\r\n */ function $a4aafd93596a3fc7$export$f07c621b7d36d1ec() {\n    if (!$a4aafd93596a3fc7$export$c9f6e7e078edfb63) return;\n    const newData = $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).currentWeekSets[muscle] || 0);\n    const newColors = $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).getVolumeColor(muscle));\n    // Update current sets data\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[0].data = newData;\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[0].backgroundColor = newColors;\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[0].borderColor = newColors.map((color)=>color.replace('0.6', '1'));\n    // Update landmark lines\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[1].data = $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).volumeLandmarks[muscle].MEV);\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[2].data = $a4aafd93596a3fc7$var$muscles.map((muscle)=>(0, $gBc5V.default).volumeLandmarks[muscle].MRV);\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.update();\n}\n/**\r\n * Reset chart data\r\n */ function $a4aafd93596a3fc7$export$1be07204ac5fe8ce() {\n    $a4aafd93596a3fc7$var$muscles.forEach((muscle)=>{\n        (0, $gBc5V.default).updateWeeklySets(muscle, (0, $gBc5V.default).volumeLandmarks[muscle].MEV);\n    });\n    $a4aafd93596a3fc7$export$f07c621b7d36d1ec();\n}\n/**\r\n * Show deload visualization\r\n */ function $a4aafd93596a3fc7$export$a633f605a08af7f2() {\n    if (!$a4aafd93596a3fc7$export$c9f6e7e078edfb63) return;\n    // Temporarily show 50% volume\n    const deloadData = $a4aafd93596a3fc7$var$muscles.map((muscle)=>Math.round((0, $gBc5V.default).volumeLandmarks[muscle].MEV * 0.5));\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[0].data = deloadData;\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.data.datasets[0].backgroundColor = $a4aafd93596a3fc7$var$muscles.map(()=>'rgba(100, 100, 100, 0.6)');\n    $a4aafd93596a3fc7$export$c9f6e7e078edfb63.update();\n    // Reset after 3 seconds\n    setTimeout(()=>{\n        $a4aafd93596a3fc7$export$f07c621b7d36d1ec();\n    }, 3000);\n}\n/**\r\n * Add volume landmarks overlay to chart\r\n */ function $a4aafd93596a3fc7$export$d2cfe3709d2fae1f() {\n    if (!$a4aafd93596a3fc7$export$c9f6e7e078edfb63) return;\n    // Landmarks are already built into the chart\n    // This function maintains compatibility with existing code\n    console.log('Volume landmarks are permanently displayed on chart');\n}\n/**\r\n * Export chart as image for reports\r\n */ function $a4aafd93596a3fc7$export$f09d42cecf7f68cf() {\n    if (!$a4aafd93596a3fc7$export$c9f6e7e078edfb63) {\n        console.warn('No chart available for export');\n        return null;\n    }\n    try {\n        // Get chart as base64 image\n        const base64Image = $a4aafd93596a3fc7$export$c9f6e7e078edfb63.toBase64Image('image/png', 1);\n        // Create download link\n        const link = document.createElement('a');\n        link.download = `workout-volume-chart-week-${(0, $gBc5V.default).weekNo}.png`;\n        link.href = base64Image;\n        // Trigger download\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        // Show success message\n        const notification = document.createElement('div');\n        notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #4CAF50;\n      color: white;\n      padding: 12px 20px;\n      border-radius: 8px;\n      z-index: 10000;\n      font-weight: 600;\n    `;\n        notification.textContent = 'Chart exported successfully!';\n        document.body.appendChild(notification);\n        setTimeout(()=>{\n            document.body.removeChild(notification);\n        }, 3000);\n        return base64Image;\n    } catch (e) {\n        console.error('Chart export failed:', e);\n        // Show error message\n        const notification = document.createElement('div');\n        notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #f44336;\n      color: white;\n      padding: 12px 20px;\n      border-radius: 8px;\n      z-index: 10000;\n      font-weight: 600;\n    `;\n        notification.textContent = 'Export failed. Please try again.';\n        document.body.appendChild(notification);\n        setTimeout(()=>{\n            document.body.removeChild(notification);\n        }, 3000);\n        return null;\n    }\n}\n\n});\nparcelRegister(\"gBc5V\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $c1597bc275c4ccd9$export$2e2bcd8739ae039);\n/**\r\n * TrainingState Singleton - Renaissance Periodization Implementation\r\n * Manages all training state including volume landmarks, meso progression, and deload logic\r\n */ class $c1597bc275c4ccd9$var$TrainingState {\n    constructor(){\n        if ($c1597bc275c4ccd9$var$TrainingState.instance) return $c1597bc275c4ccd9$var$TrainingState.instance;\n        // Core RP Volume Landmarks (defaults from RP literature)\n        this.volumeLandmarks = {\n            'Chest': {\n                MV: 4,\n                MEV: 8,\n                MAV: 16,\n                MRV: 22\n            },\n            'Back': {\n                MV: 6,\n                MEV: 10,\n                MAV: 20,\n                MRV: 25\n            },\n            'Quads': {\n                MV: 6,\n                MEV: 10,\n                MAV: 20,\n                MRV: 25\n            },\n            'Hamstrings': {\n                MV: 4,\n                MEV: 6,\n                MAV: 16,\n                MRV: 20\n            },\n            'Shoulders': {\n                MV: 4,\n                MEV: 8,\n                MAV: 16,\n                MRV: 20\n            },\n            'Biceps': {\n                MV: 4,\n                MEV: 6,\n                MAV: 14,\n                MRV: 20\n            },\n            'Triceps': {\n                MV: 4,\n                MEV: 6,\n                MAV: 14,\n                MRV: 18\n            },\n            'Calves': {\n                MV: 6,\n                MEV: 8,\n                MAV: 16,\n                MRV: 22\n            },\n            'Abs': {\n                MV: 0,\n                MEV: 6,\n                MAV: 16,\n                MRV: 25\n            },\n            'Forearms': {\n                MV: 2,\n                MEV: 4,\n                MAV: 10,\n                MRV: 16\n            },\n            'Neck': {\n                MV: 0,\n                MEV: 2,\n                MAV: 8,\n                MRV: 12\n            },\n            'Traps': {\n                MV: 2,\n                MEV: 4,\n                MAV: 12,\n                MRV: 16\n            }\n        };\n        // Training progression state\n        this.weekNo = 1;\n        this.mesoLen = 4;\n        this.blockNo = 1;\n        this.deloadPhase = false;\n        this.resensitizationPhase = false;\n        // Current week data\n        this.currentWeekSets = {};\n        this.lastWeekSets = {};\n        // Initialize current week sets at MEV\n        Object.keys(this.volumeLandmarks).forEach((muscle)=>{\n            this.currentWeekSets[muscle] = this.volumeLandmarks[muscle].MEV;\n            this.lastWeekSets[muscle] = this.volumeLandmarks[muscle].MEV;\n        });\n        // Performance tracking for deload detection\n        this.consecutiveMRVWeeks = 0;\n        this.recoverySessionsThisWeek = 0;\n        this.totalMusclesNeedingRecovery = 0;\n        $c1597bc275c4ccd9$var$TrainingState.instance = this;\n        this.loadState();\n    }\n    // Calculate target RIR based on meso progression\n    getTargetRIR() {\n        const startRIR = 3.0;\n        const endRIR = 0.5;\n        const progressionRate = (startRIR - endRIR) / (this.mesoLen - 1);\n        const targetRIR = startRIR - progressionRate * (this.weekNo - 1);\n        return Math.max(endRIR, Math.min(startRIR, targetRIR));\n    }\n    // Get volume status for a muscle\n    getVolumeStatus(muscle, sets = null) {\n        const currentSets = sets !== null ? sets : this.currentWeekSets[muscle];\n        const landmarks = this.volumeLandmarks[muscle];\n        if (currentSets < landmarks.MV) return 'under-minimum';\n        if (currentSets < landmarks.MEV) return 'maintenance';\n        if (currentSets < landmarks.MAV) return 'optimal';\n        if (currentSets < landmarks.MRV) return 'high';\n        return 'maximum';\n    }\n    // Get volume zone color for charting\n    getVolumeColor(muscle, sets = null) {\n        const status = this.getVolumeStatus(muscle, sets);\n        const colors = {\n            'under-minimum': '#ff4444',\n            'maintenance': '#ffaa00',\n            'optimal': '#44ff44',\n            'high': '#ffff44',\n            'maximum': '#ff4444' // Red\n        };\n        return colors[status];\n    }\n    // Update weekly sets for a muscle\n    updateWeeklySets(muscle, sets) {\n        this.currentWeekSets[muscle] = Math.max(0, sets);\n        this.saveState();\n    }\n    // Add sets to a muscle\n    addSets(muscle, additionalSets) {\n        this.currentWeekSets[muscle] += additionalSets;\n        this.currentWeekSets[muscle] = Math.max(0, this.currentWeekSets[muscle]);\n        this.saveState();\n    }\n    // Check if deload is needed\n    shouldDeload() {\n        // Check 1: Consecutive weeks at MRV\n        if (this.consecutiveMRVWeeks >= 2) return true;\n        // Check 2: Most muscles need recovery\n        const totalMuscles = Object.keys(this.volumeLandmarks).length;\n        if (this.totalMusclesNeedingRecovery >= Math.ceil(totalMuscles / 2)) return true;\n        // Check 3: End of meso\n        if (this.weekNo >= this.mesoLen) return true;\n        return false;\n    }\n    // Check if resensitization is needed (every 3-6 mesos)\n    shouldResensitize() {\n        return this.blockNo % 4 === 0; // Every 4 blocks (adjustable)\n    }\n    // Start deload phase\n    startDeload() {\n        this.deloadPhase = true;\n        // Reduce all sets to 50% of MEV\n        Object.keys(this.volumeLandmarks).forEach((muscle)=>{\n            const deloadSets = Math.round(this.volumeLandmarks[muscle].MEV * 0.5);\n            this.currentWeekSets[muscle] = deloadSets;\n        });\n        this.saveState();\n    }\n    // Start resensitization phase\n    startResensitization() {\n        this.resensitizationPhase = true;\n        // Set all muscles to MV\n        Object.keys(this.volumeLandmarks).forEach((muscle)=>{\n            this.currentWeekSets[muscle] = this.volumeLandmarks[muscle].MV;\n        });\n        this.saveState();\n    }\n    // Progress to next week\n    nextWeek() {\n        // Store last week's data\n        this.lastWeekSets = {\n            ...this.currentWeekSets\n        };\n        // Check for MRV breach\n        const mrvBreaches = Object.keys(this.volumeLandmarks).filter((muscle)=>this.currentWeekSets[muscle] >= this.volumeLandmarks[muscle].MRV);\n        if (mrvBreaches.length > 0) this.consecutiveMRVWeeks++;\n        else this.consecutiveMRVWeeks = 0;\n        // Progress week\n        this.weekNo++;\n        // Check for meso completion\n        if (this.weekNo > this.mesoLen) {\n            this.weekNo = 1;\n            this.blockNo++;\n            this.consecutiveMRVWeeks = 0;\n        }\n        // Reset weekly counters\n        this.recoverySessionsThisWeek = 0;\n        this.totalMusclesNeedingRecovery = 0;\n        this.saveState();\n    }\n    // Reset week (for testing/corrections)\n    resetWeek() {\n        Object.keys(this.volumeLandmarks).forEach((muscle)=>{\n            this.currentWeekSets[muscle] = this.volumeLandmarks[muscle].MEV;\n        });\n        this.saveState();\n    }\n    // Update volume landmarks for a muscle\n    updateVolumeLandmarks(muscle, landmarks) {\n        this.volumeLandmarks[muscle] = {\n            ...this.volumeLandmarks[muscle],\n            ...landmarks\n        };\n        this.saveState();\n    }\n    // Calculate recovery volume\n    getRecoveryVolume(muscle, hasIllness = false) {\n        const landmarks = this.volumeLandmarks[muscle];\n        const midpoint = Math.round((landmarks.MEV + landmarks.MRV) / 2);\n        const adjustment = hasIllness ? 2 : 1;\n        const recoveryVolume = midpoint - adjustment;\n        return Math.max(recoveryVolume, Math.ceil(landmarks.MEV * 0.5));\n    }\n    // Save state to localStorage\n    saveState() {\n        const state = {\n            volumeLandmarks: this.volumeLandmarks,\n            weekNo: this.weekNo,\n            mesoLen: this.mesoLen,\n            blockNo: this.blockNo,\n            deloadPhase: this.deloadPhase,\n            resensitizationPhase: this.resensitizationPhase,\n            currentWeekSets: this.currentWeekSets,\n            lastWeekSets: this.lastWeekSets,\n            consecutiveMRVWeeks: this.consecutiveMRVWeeks,\n            recoverySessionsThisWeek: this.recoverySessionsThisWeek,\n            totalMusclesNeedingRecovery: this.totalMusclesNeedingRecovery\n        };\n        localStorage.setItem('rp-training-state', JSON.stringify(state));\n    }\n    // Load state from localStorage\n    loadState() {\n        const saved = localStorage.getItem('rp-training-state');\n        if (saved) try {\n            const state = JSON.parse(saved);\n            Object.assign(this, state);\n        } catch (e) {\n            console.warn('Failed to load training state, using defaults');\n        }\n    }\n    // Migrate legacy localStorage data\n    migrateLegacyData() {\n        const muscles = Object.keys(this.volumeLandmarks);\n        let hasLegacyData = false;\n        muscles.forEach((muscle)=>{\n            // Check for old format keys\n            const oldKey = `week-1-${muscle}`;\n            const oldValue = localStorage.getItem(oldKey);\n            if (oldValue) {\n                this.currentWeekSets[muscle] = parseInt(oldValue, 10);\n                localStorage.removeItem(oldKey);\n                hasLegacyData = true;\n            }\n            // Migrate MEV/MRV settings\n            const mevKey = `${muscle}-MEV`;\n            const mrvKey = `${muscle}-MRV`;\n            const mevValue = localStorage.getItem(mevKey);\n            const mrvValue = localStorage.getItem(mrvKey);\n            if (mevValue || mrvValue) {\n                this.volumeLandmarks[muscle] = {\n                    ...this.volumeLandmarks[muscle],\n                    MEV: mevValue ? parseInt(mevValue, 10) : this.volumeLandmarks[muscle].MEV,\n                    MRV: mrvValue ? parseInt(mrvValue, 10) : this.volumeLandmarks[muscle].MRV\n                };\n                if (mevValue) localStorage.removeItem(mevKey);\n                if (mrvValue) localStorage.removeItem(mrvKey);\n                hasLegacyData = true;\n            }\n        });\n        if (hasLegacyData) {\n            this.saveState();\n            console.log('Legacy data migrated to new RP training state');\n        }\n    }\n    // Get current state summary\n    getStateSummary() {\n        return {\n            week: this.weekNo,\n            meso: this.mesoLen,\n            block: this.blockNo,\n            targetRIR: this.getTargetRIR(),\n            deloadRecommended: this.shouldDeload(),\n            resensitizationRecommended: this.shouldResensitize(),\n            currentPhase: this.deloadPhase ? 'deload' : this.resensitizationPhase ? 'resensitization' : 'accumulation'\n        };\n    }\n}\n// Export singleton instance\nconst $c1597bc275c4ccd9$var$trainingState = new $c1597bc275c4ccd9$var$TrainingState();\nvar $c1597bc275c4ccd9$export$2e2bcd8739ae039 = $c1597bc275c4ccd9$var$trainingState;\n// Also make available globally for legacy compatibility\nif (typeof window !== 'undefined') window.trainingState = $c1597bc275c4ccd9$var$trainingState;\n\n});\n\n\nparcelRegister(\"jlKM8\", function(module, exports) {\n\n$parcel$export(module.exports, \"scoreStimulus\", () => $e164431b984951c9$export$18b9fbb49c39d8df);\n$parcel$export(module.exports, \"setProgressionAlgorithm\", () => $e164431b984951c9$export$29edd766f0a47f8a);\n$parcel$export(module.exports, \"analyzeVolumeStatus\", () => $e164431b984951c9$export$b31b69977bb86b2d);\n$parcel$export(module.exports, \"validateVolumeInput\", () => $e164431b984951c9$export$8d707a3cbe195ceb);\n$parcel$export(module.exports, \"getVolumeProgression\", () => $e164431b984951c9$export$8a692c73ed76fb03);\n$parcel$export(module.exports, \"analyzeDeloadNeed\", () => $e164431b984951c9$export$4cb49ae975c76e14);\n/**\r\n * Renaissance Periodization Volume Algorithms\r\n * Implements RP Table 2.2 (MEV Stimulus Estimator) and Table 2.3 (Set Progression Algorithm)\r\n */ \nvar $gBc5V = parcelRequire(\"gBc5V\");\n/**\r\n * RP Table 2.2: MEV Stimulus Estimator\r\n * Scores stimulus quality based on mind-muscle connection, pump, and disruption\r\n * @param {Object} feedback - {mmc: 0-3, pump: 0-3, disruption: 0-3}\r\n * @returns {Object} - {score: 0-9, advice: string, action: string}\r\n */ function $e164431b984951c9$export$18b9fbb49c39d8df({ mmc: mmc, pump: pump, disruption: disruption }) {\n    // Validate inputs\n    const clamp = (val, min, max)=>Math.max(min, Math.min(max, val));\n    const clampedMmc = clamp(mmc, 0, 3);\n    const clampedPump = clamp(pump, 0, 3);\n    const clampedDisruption = clamp(disruption, 0, 3);\n    const totalScore = clampedMmc + clampedPump + clampedDisruption;\n    let advice, action, setChange;\n    if (totalScore <= 3) {\n        advice = `Stimulus too low (${totalScore}/9) \\u{2192} Add 2 sets next session`;\n        action = 'add_sets';\n        setChange = 2;\n    } else if (totalScore <= 6) {\n        advice = `Stimulus adequate (${totalScore}/9) \\u{2192} Keep sets the same`;\n        action = 'maintain';\n        setChange = 0;\n    } else {\n        advice = `Stimulus excessive (${totalScore}/9) \\u{2192} Remove 1-2 sets next session`;\n        action = 'reduce_sets';\n        setChange = -1;\n    }\n    return {\n        score: totalScore,\n        advice: advice,\n        action: action,\n        setChange: setChange,\n        breakdown: {\n            mmc: clampedMmc,\n            pump: clampedPump,\n            disruption: clampedDisruption\n        }\n    };\n}\n/**\r\n * RP Table 2.3: Set Progression Algorithm\r\n * Matrix lookup based on soreness level and performance vs last session\r\n * @param {number} soreness - 0-3 (0=none, 1=mild, 2=moderate, 3=high)\r\n * @param {number} performance - 0-3 (0=worse, 1=same, 2=better, 3=much better)\r\n * @returns {Object} - {advice: string, action: string, setChange: number}\r\n */ function $e164431b984951c9$export$29edd766f0a47f8a(soreness, performance) {\n    // Clamp inputs to valid ranges\n    const clamp = (val, min, max)=>Math.max(min, Math.min(max, val));\n    const s = clamp(soreness, 0, 3);\n    const p = clamp(performance, 0, 3);\n    // RP Set Progression Matrix [soreness][performance]\n    const progressionMatrix = [\n        // Soreness 0 (None)\n        [\n            {\n                advice: \"Add 1 set next session\",\n                action: \"add_sets\",\n                setChange: 1\n            },\n            {\n                advice: \"Add 2 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            },\n            {\n                advice: \"Add 2-3 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            },\n            {\n                advice: \"Add 2-3 sets next session\",\n                action: \"add_sets\",\n                setChange: 3\n            } // Performance 3 (much better)\n        ],\n        // Soreness 1 (Mild)\n        [\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            },\n            {\n                advice: \"Add 1 set next session\",\n                action: \"add_sets\",\n                setChange: 1\n            },\n            {\n                advice: \"Add 2 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            },\n            {\n                advice: \"Add 2-3 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            } // Performance 3\n        ],\n        // Soreness 2 (Moderate)\n        [\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            },\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            },\n            {\n                advice: \"Add 1 set next session\",\n                action: \"add_sets\",\n                setChange: 1\n            } // Performance 3\n        ],\n        // Soreness 3 (High)\n        [\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            } // Performance 3\n        ]\n    ];\n    return progressionMatrix[s][p];\n}\n/**\r\n * Analyze current volume status relative to landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} currentSets - Current weekly sets (optional, uses state if not provided)\r\n * @returns {Object} - Volume analysis\r\n */ function $e164431b984951c9$export$b31b69977bb86b2d(muscle, currentSets = null) {\n    const sets = currentSets !== null ? currentSets : (0, $gBc5V.default).currentWeekSets[muscle];\n    const landmarks = (0, $gBc5V.default).volumeLandmarks[muscle];\n    if (!landmarks) throw new Error(`Unknown muscle group: ${muscle}`);\n    const status = (0, $gBc5V.default).getVolumeStatus(muscle, sets);\n    const percentage = sets / landmarks.MRV * 100;\n    let recommendation = '';\n    let urgency = 'normal';\n    switch(status){\n        case 'under-minimum':\n            recommendation = `Below MV (${landmarks.MV}). Increase volume significantly.`;\n            urgency = 'high';\n            break;\n        case 'maintenance':\n            recommendation = `In maintenance zone (${landmarks.MV}-${landmarks.MEV}). Consider increasing for growth.`;\n            urgency = 'low';\n            break;\n        case 'optimal':\n            recommendation = `In optimal zone (${landmarks.MEV}-${landmarks.MAV}). Continue progressive overload.`;\n            urgency = 'normal';\n            break;\n        case 'high':\n            recommendation = `High volume zone (${landmarks.MAV}-${landmarks.MRV}). Monitor recovery closely.`;\n            urgency = 'medium';\n            break;\n        case 'maximum':\n            recommendation = `At/above MRV (${landmarks.MRV}). Deload recommended.`;\n            urgency = 'high';\n            break;\n    }\n    return {\n        muscle: muscle,\n        currentSets: sets,\n        landmarks: landmarks,\n        status: status,\n        percentage: Math.round(percentage),\n        recommendation: recommendation,\n        urgency: urgency,\n        color: (0, $gBc5V.default).getVolumeColor(muscle, sets)\n    };\n}\n/**\r\n * Calculate recovery session volume\r\n * @param {string} muscle - Muscle group name\r\n * @param {boolean} hasIllness - Whether trainee has illness/injury\r\n * @returns {Object} - Recovery session recommendation\r\n */ function $e164431b984951c9$export$5093fcc2dc47d960(muscle, hasIllness = false) {\n    const landmarks = (0, $gBc5V.default).volumeLandmarks[muscle];\n    const recoveryVolume = (0, $gBc5V.default).getRecoveryVolume(muscle, hasIllness);\n    return {\n        muscle: muscle,\n        recommendedSets: recoveryVolume,\n        reasoning: hasIllness ? 'illness adjustment' : 'standard recovery',\n        landmarks: landmarks,\n        percentage: Math.round(recoveryVolume / landmarks.MEV * 100)\n    };\n}\n/**\r\n * Validate volume input against landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} proposedSets - Proposed weekly sets\r\n * @returns {Object} - Validation result\r\n */ function $e164431b984951c9$export$8d707a3cbe195ceb(muscle, proposedSets) {\n    const landmarks = (0, $gBc5V.default).volumeLandmarks[muscle];\n    const isValid = proposedSets >= 0 && proposedSets <= landmarks.MRV * 1.2; // Allow 20% over MRV\n    let warning = '';\n    if (proposedSets < 0) warning = 'Sets cannot be negative';\n    else if (proposedSets > landmarks.MRV) warning = `Above MRV (${landmarks.MRV}). Consider deload.`;\n    else if (proposedSets < landmarks.MV) warning = `Below MV (${landmarks.MV}). May not be sufficient for adaptation.`;\n    return {\n        isValid: isValid,\n        warning: warning,\n        proposedSets: proposedSets,\n        landmarks: landmarks\n    };\n}\n/**\r\n * Get volume progression recommendation for next week\r\n * @param {string} muscle - Muscle group name\r\n * @param {Object} feedback - Latest training feedback\r\n * @returns {Object} - Next week recommendation\r\n */ function $e164431b984951c9$export$8a692c73ed76fb03(muscle, feedback) {\n    const currentSets = (0, $gBc5V.default).currentWeekSets[muscle];\n    const volumeAnalysis = $e164431b984951c9$export$b31b69977bb86b2d(muscle);\n    // Get stimulus score\n    const stimulusResult = $e164431b984951c9$export$18b9fbb49c39d8df(feedback.stimulus);\n    // Get set progression recommendation\n    const progressionResult = $e164431b984951c9$export$29edd766f0a47f8a(feedback.soreness, feedback.performance);\n    // Combine recommendations with volume constraints\n    let finalSetChange = progressionResult.setChange;\n    let finalAdvice = progressionResult.advice;\n    // Override if at volume limits\n    if (volumeAnalysis.status === 'maximum' && finalSetChange > 0) {\n        finalSetChange = 0;\n        finalAdvice = \"At MRV limit. Hold sets or consider deload.\";\n    }\n    if (volumeAnalysis.status === 'under-minimum' && finalSetChange <= 0) {\n        finalSetChange = 2;\n        finalAdvice = \"Below minimum volume. Add sets regardless of fatigue.\";\n    }\n    // Special handling for recovery sessions\n    if (progressionResult.action === 'recovery') {\n        const recoveryVolume = $e164431b984951c9$export$5093fcc2dc47d960(muscle, feedback.hasIllness);\n        finalSetChange = recoveryVolume.recommendedSets - currentSets;\n        finalAdvice = `Recovery session: ${recoveryVolume.recommendedSets} sets (${recoveryVolume.reasoning})`;\n    }\n    const projectedSets = Math.max(0, currentSets + finalSetChange);\n    return {\n        muscle: muscle,\n        currentSets: currentSets,\n        projectedSets: projectedSets,\n        setChange: finalSetChange,\n        advice: finalAdvice,\n        stimulusScore: stimulusResult.score,\n        volumeStatus: volumeAnalysis.status,\n        targetRIR: (0, $gBc5V.default).getTargetRIR(),\n        deloadRecommended: (0, $gBc5V.default).shouldDeload()\n    };\n}\n/**\r\n * Analyze all muscles for deload necessity\r\n * @returns {Object} - Deload analysis\r\n */ function $e164431b984951c9$export$4cb49ae975c76e14() {\n    const muscles = Object.keys((0, $gBc5V.default).volumeLandmarks);\n    const mrvBreaches = muscles.filter((muscle)=>(0, $gBc5V.default).getVolumeStatus(muscle) === 'maximum');\n    const shouldDeload = (0, $gBc5V.default).shouldDeload();\n    const reasons = [];\n    if ((0, $gBc5V.default).consecutiveMRVWeeks >= 2) reasons.push('Two consecutive weeks at MRV');\n    if ((0, $gBc5V.default).totalMusclesNeedingRecovery >= Math.ceil(muscles.length / 2)) reasons.push('Most muscles need recovery sessions');\n    if ((0, $gBc5V.default).weekNo >= (0, $gBc5V.default).mesoLen) reasons.push('End of mesocycle reached');\n    if (mrvBreaches.length >= Math.ceil(muscles.length / 3)) reasons.push(`${mrvBreaches.length} muscle groups at/above MRV`);\n    return {\n        shouldDeload: shouldDeload,\n        reasons: reasons,\n        mrvBreaches: mrvBreaches,\n        consecutiveMRVWeeks: (0, $gBc5V.default).consecutiveMRVWeeks,\n        currentWeek: (0, $gBc5V.default).weekNo,\n        mesoLength: (0, $gBc5V.default).mesoLen,\n        musclesNeedingRecovery: (0, $gBc5V.default).totalMusclesNeedingRecovery\n    };\n}\n\n});\n\nparcelRegister(\"9Ev1P\", function(module, exports) {\n\n$parcel$export(module.exports, \"calculateTargetRIR\", () => $706feb1901751bf0$export$aa142ff646b13b0f);\n$parcel$export(module.exports, \"validateEffortLevel\", () => $706feb1901751bf0$export$8bb5b09bc31b1524);\n/**\r\n * Renaissance Periodization Effort Management\r\n * Handles RIR (Reps In Reserve) calculations and effort progression\r\n */ \nvar $gBc5V = parcelRequire(\"gBc5V\");\n/**\r\n * Calculate target RIR based on meso progression\r\n * @param {number} weekNumber - Current week (1-based)\r\n * @param {number} mesoLength - Total weeks in mesocycle\r\n * @param {number} startRIR - Starting RIR (default 3)\r\n * @param {number} endRIR - Ending RIR (default 0.5)\r\n * @returns {Object} - RIR calculation result\r\n */ function $706feb1901751bf0$export$aa142ff646b13b0f(weekNumber = null, mesoLength = null, startRIR = 3, endRIR = 0.5) {\n    const week = weekNumber || (0, $gBc5V.default).weekNo;\n    const mesoLen = mesoLength || (0, $gBc5V.default).mesoLen;\n    if (week > mesoLen) return {\n        targetRIR: startRIR,\n        warning: 'Week exceeds mesocycle length',\n        progression: 0\n    };\n    // Linear progression from start to end RIR\n    const progressionRate = (startRIR - endRIR) / (mesoLen - 1);\n    const targetRIR = startRIR - progressionRate * (week - 1);\n    const clampedRIR = Math.max(endRIR, Math.min(startRIR, targetRIR));\n    // Calculate progression percentage\n    const progression = (week - 1) / (mesoLen - 1) * 100;\n    let intensityLevel = 'moderate';\n    let advice = '';\n    if (clampedRIR >= 2.5) {\n        intensityLevel = 'low';\n        advice = 'Focus on form and mind-muscle connection';\n    } else if (clampedRIR >= 2.0) {\n        intensityLevel = 'moderate';\n        advice = 'Balanced effort - challenge without excessive fatigue';\n    } else if (clampedRIR >= 1.0) {\n        intensityLevel = 'high';\n        advice = 'High effort - monitor recovery closely';\n    } else {\n        intensityLevel = 'maximum';\n        advice = 'Maximum effort - deload approaching';\n    }\n    return {\n        targetRIR: Math.round(clampedRIR * 2) / 2,\n        intensityLevel: intensityLevel,\n        advice: advice,\n        progression: Math.round(progression),\n        week: week,\n        mesoLength: mesoLen\n    };\n}\n/**\r\n * Validate actual RIR against target\r\n * @param {number} actualRIR - Actual RIR reported\r\n * @param {number} targetRIR - Target RIR for the week\r\n * @param {number} tolerance - Acceptable deviation (default 1)\r\n * @returns {Object} - Validation result\r\n */ function $706feb1901751bf0$export$8bb5b09bc31b1524(actualRIR, targetRIR = null, tolerance = 1) {\n    const target = targetRIR || (0, $gBc5V.default).getTargetRIR();\n    const deviation = Math.abs(actualRIR - target);\n    const isWithinTolerance = deviation <= tolerance;\n    let feedback = '';\n    let recommendation = '';\n    let urgency = 'normal';\n    if (isWithinTolerance) {\n        feedback = `On target (${actualRIR} vs ${target} RIR)`;\n        recommendation = 'Continue current effort level';\n        urgency = 'normal';\n    } else if (actualRIR > target) {\n        const difference = actualRIR - target;\n        feedback = `Too easy (${difference} RIR above target)`;\n        recommendation = difference > 2 ? 'Increase weight significantly' : 'Increase weight moderately';\n        urgency = difference > 2 ? 'high' : 'medium';\n    } else {\n        const difference = target - actualRIR;\n        feedback = `Too hard (${difference} RIR below target)`;\n        recommendation = difference > 2 ? 'Reduce weight significantly' : 'Reduce weight slightly';\n        urgency = difference > 2 ? 'high' : 'medium';\n    }\n    return {\n        actualRIR: actualRIR,\n        targetRIR: target,\n        deviation: deviation,\n        isWithinTolerance: isWithinTolerance,\n        feedback: feedback,\n        recommendation: recommendation,\n        urgency: urgency\n    };\n}\n/**\r\n * Calculate effort progression for next session\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} lastSession - Last session data\r\n * @returns {Object} - Effort progression recommendation\r\n */ function $706feb1901751bf0$export$5b0f1c790e7312ac(muscle, lastSession) {\n    const currentRIR = (0, $gBc5V.default).getTargetRIR();\n    const volumeStatus = (0, $gBc5V.default).getVolumeStatus(muscle);\n    let weightRecommendation = 'maintain';\n    let rirAdjustment = 0;\n    let advice = '';\n    // Base progression on last session performance\n    if (lastSession.actualRIR < lastSession.targetRIR - 1.5) {\n        // Too hard last time\n        weightRecommendation = 'decrease';\n        rirAdjustment = 0.5;\n        advice = 'Reduce weight to hit target RIR';\n    } else if (lastSession.actualRIR > lastSession.targetRIR + 1.5) {\n        // Too easy last time\n        weightRecommendation = 'increase';\n        rirAdjustment = -0.5;\n        advice = 'Increase weight to hit target RIR';\n    } else // On target\n    if (volumeStatus === 'maximum') advice = 'Maintain weight - at volume limit';\n    else advice = 'Good effort level - continue progression';\n    // Adjust based on volume status\n    if (volumeStatus === 'maximum' && weightRecommendation === 'increase') {\n        weightRecommendation = 'maintain';\n        advice = 'At MRV - avoid adding intensity stress';\n    }\n    const projectedRIR = Math.max(0, currentRIR + rirAdjustment);\n    return {\n        muscle: muscle,\n        currentTargetRIR: currentRIR,\n        projectedRIR: projectedRIR,\n        weightRecommendation: weightRecommendation,\n        advice: advice,\n        volumeStatus: volumeStatus\n    };\n}\n/**\r\n * Calculate autoregulation recommendations\r\n * @param {Object} sessionFeedback - Real-time session feedback\r\n * @returns {Object} - Autoregulation advice\r\n */ function $706feb1901751bf0$export$38d8c5d0e74ab0a0(sessionFeedback) {\n    const { actualRIR: actualRIR, plannedRIR: plannedRIR, setNumber: setNumber, totalPlannedSets: totalPlannedSets, muscle: muscle } = sessionFeedback;\n    const deviation = actualRIR - plannedRIR;\n    let advice = '';\n    let action = 'continue';\n    let weightAdjustment = 0; // Percentage\n    // Early sets (first 1/3)\n    if (setNumber <= Math.ceil(totalPlannedSets / 3)) {\n        if (deviation > 1.5) {\n            advice = 'Weight too light - increase by 5-10%';\n            action = 'increase_weight';\n            weightAdjustment = 7.5;\n        } else if (deviation < -1.5) {\n            advice = 'Weight too heavy - decrease by 5-10%';\n            action = 'decrease_weight';\n            weightAdjustment = -7.5;\n        } else advice = 'Weight appropriate - continue';\n    } else if (setNumber <= Math.ceil(totalPlannedSets * 2 / 3)) {\n        if (deviation > 2) {\n            advice = 'Still too easy - increase weight';\n            action = 'increase_weight';\n            weightAdjustment = 5;\n        } else if (deviation < -2) {\n            advice = 'Too fatiguing - consider stopping early';\n            action = 'consider_stopping';\n            weightAdjustment = 0;\n        } else advice = 'Good progression - continue';\n    } else {\n        if (deviation < -1) {\n            advice = 'Very fatiguing - consider stopping to preserve recovery';\n            action = 'consider_stopping';\n        } else if (deviation > 2) {\n            advice = 'Could push harder - add 1-2 sets if recovering well';\n            action = 'consider_adding_sets';\n        } else advice = 'Appropriate fatigue for final sets';\n    }\n    return {\n        setNumber: setNumber,\n        totalPlannedSets: totalPlannedSets,\n        actualRIR: actualRIR,\n        plannedRIR: plannedRIR,\n        deviation: deviation,\n        advice: advice,\n        action: action,\n        weightAdjustment: weightAdjustment\n    };\n}\n/**\r\n * Generate weekly effort summary\r\n * @returns {Object} - Weekly effort analysis\r\n */ function $706feb1901751bf0$export$95540aa25eb86c4e() {\n    const currentWeek = (0, $gBc5V.default).weekNo;\n    const mesoLength = (0, $gBc5V.default).mesoLen;\n    const targetRIR = (0, $gBc5V.default).getTargetRIR();\n    const weeklyAdvice = [];\n    // Week-specific advice\n    if (currentWeek === 1) {\n        weeklyAdvice.push('Focus on technique and mind-muscle connection');\n        weeklyAdvice.push('Establish baseline weights for the mesocycle');\n    } else if (currentWeek === mesoLength) {\n        weeklyAdvice.push('Peak intensity week - push close to failure');\n        weeklyAdvice.push('Prepare for upcoming deload');\n    } else if (currentWeek > mesoLength * 0.75) {\n        weeklyAdvice.push('High intensity phase - monitor recovery closely');\n        weeklyAdvice.push('Focus on performance over volume additions');\n    } else {\n        weeklyAdvice.push('Progressive overload phase - gradually increase demands');\n        weeklyAdvice.push('Balance volume and intensity progression');\n    }\n    return {\n        currentWeek: currentWeek,\n        mesoLength: mesoLength,\n        targetRIR: targetRIR,\n        weeklyAdvice: weeklyAdvice,\n        phaseDescription: $706feb1901751bf0$var$getPhaseDescription(currentWeek, mesoLength)\n    };\n}\n/**\r\n * Get phase description based on week\r\n * @param {number} week - Current week\r\n * @param {number} mesoLength - Total meso length\r\n * @returns {string} - Phase description\r\n */ function $706feb1901751bf0$var$getPhaseDescription(week, mesoLength) {\n    const percentage = week / mesoLength * 100;\n    if (percentage <= 25) return 'Accumulation Phase - Building foundation';\n    else if (percentage <= 60) return 'Progression Phase - Steady overload';\n    else if (percentage <= 85) return 'Intensification Phase - High demands';\n    else return 'Peak Phase - Maximum effort';\n}\n\n});\n\nparcelRegister(\"76QZC\", function(module, exports) {\n\n$parcel$export(module.exports, \"analyzeFrequency\", () => $52d23339b7415571$export$e9e5518db45551d4);\n$parcel$export(module.exports, \"calculateOptimalFrequency\", () => $52d23339b7415571$export$8d40c4b24105606b);\n/**\r\n * Renaissance Periodization Fatigue Management\r\n * Handles recovery monitoring, frequency optimization, and fatigue accumulation\r\n */ \nvar $gBc5V = parcelRequire(\"gBc5V\");\n/**\r\n * Analyze recovery status and frequency optimization\r\n * @param {number} sorenessRecoveryDays - Days until soreness is gone\r\n * @param {number} currentSessionGap - Days between sessions for this muscle\r\n * @param {string} muscle - Muscle group name\r\n * @returns {Object} - Frequency analysis\r\n */ function $52d23339b7415571$export$e9e5518db45551d4(sorenessRecoveryDays, currentSessionGap, muscle = null) {\n    const recoveryTime = Math.max(0, sorenessRecoveryDays);\n    const sessionGap = Math.max(1, currentSessionGap);\n    let recommendation = '';\n    let action = '';\n    let urgency = 'normal';\n    let frequencyAdjustment = 0;\n    // Recovery vs session gap analysis\n    const recoveryRatio = recoveryTime / sessionGap;\n    if (recoveryRatio < 0.7) {\n        // Recovering much faster than session frequency\n        recommendation = \"You heal early \\u2192 Add one session per week\";\n        action = 'increase_frequency';\n        frequencyAdjustment = 1;\n        urgency = 'medium';\n    } else if (recoveryRatio > 1.3) {\n        // Still sore when next session is due\n        recommendation = \"Recovery lags \\u2192 Insert an extra rest day\";\n        action = 'decrease_frequency';\n        frequencyAdjustment = -1;\n        urgency = 'high';\n    } else {\n        // Optimal recovery timing\n        recommendation = 'Frequency is optimal';\n        action = 'maintain';\n        frequencyAdjustment = 0;\n        urgency = 'normal';\n    }\n    // Consider current volume when making frequency recommendations\n    if (muscle) {\n        const volumeStatus = (0, $gBc5V.default).getVolumeStatus(muscle);\n        if (volumeStatus === 'maximum' && action === 'increase_frequency') {\n            recommendation = 'At MRV - maintain frequency despite early recovery';\n            action = 'maintain';\n            frequencyAdjustment = 0;\n        }\n        if (volumeStatus === 'under-minimum' && action === 'decrease_frequency') {\n            recommendation = 'Below MV - consider recovery methods instead of reducing frequency';\n            action = 'improve_recovery';\n            frequencyAdjustment = 0;\n        }\n    }\n    return {\n        sorenessRecoveryDays: recoveryTime,\n        currentSessionGap: sessionGap,\n        recoveryRatio: Math.round(recoveryRatio * 100) / 100,\n        recommendation: recommendation,\n        action: action,\n        frequencyAdjustment: frequencyAdjustment,\n        urgency: urgency,\n        muscle: muscle\n    };\n}\n/**\r\n * Assess overall fatigue accumulation\r\n * @param {Object} weeklyData - Weekly fatigue metrics\r\n * @returns {Object} - Fatigue assessment\r\n */ function $52d23339b7415571$var$assessFatigueAccumulation(weeklyData) {\n    const { averageSoreness: averageSoreness = 1, sleepQuality: sleepQuality = 7, stressLevel: stressLevel = 5, musclesNeedingRecovery: musclesNeedingRecovery = 0, consecutiveMRVWeeks: consecutiveMRVWeeks = 0, performanceDecline: performanceDecline = false } = weeklyData;\n    // Calculate fatigue score (0-100)\n    let fatigueScore = 0;\n    // Soreness contribution (0-30 points)\n    fatigueScore += Math.min(30, averageSoreness / 3 * 30);\n    // Sleep quality contribution (0-20 points, inverted)\n    fatigueScore += Math.max(0, 20 - sleepQuality / 10 * 20);\n    // Stress level contribution (0-20 points)\n    fatigueScore += stressLevel / 10 * 20;\n    // Volume overreaching contribution (0-20 points)\n    const volumeOverreach = Math.min(20, musclesNeedingRecovery / 12 * 20);\n    fatigueScore += volumeOverreach;\n    // Consecutive MRV weeks (0-10 points)\n    fatigueScore += Math.min(10, consecutiveMRVWeeks * 5);\n    // Performance decline bonus\n    if (performanceDecline) fatigueScore += 10;\n    // Determine fatigue level\n    let fatigueLevel = '';\n    let recommendations = [];\n    let deloadUrgency = 'none';\n    if (fatigueScore <= 25) {\n        fatigueLevel = 'low';\n        recommendations.push('Continue current program');\n        recommendations.push('Consider volume progression opportunities');\n    } else if (fatigueScore <= 50) {\n        fatigueLevel = 'moderate';\n        recommendations.push('Monitor recovery closely');\n        recommendations.push('Ensure adequate sleep and nutrition');\n        deloadUrgency = 'low';\n    } else if (fatigueScore <= 75) {\n        fatigueLevel = 'high';\n        recommendations.push('Reduce training stress');\n        recommendations.push('Consider recovery week');\n        recommendations.push('Prioritize sleep and stress management');\n        deloadUrgency = 'medium';\n    } else {\n        fatigueLevel = 'excessive';\n        recommendations.push('Implement deload immediately');\n        recommendations.push('Address sleep and lifestyle factors');\n        recommendations.push('Consider extending deload period');\n        deloadUrgency = 'high';\n    }\n    return {\n        fatigueScore: Math.round(fatigueScore),\n        fatigueLevel: fatigueLevel,\n        recommendations: recommendations,\n        deloadUrgency: deloadUrgency,\n        breakdown: {\n            soreness: Math.min(30, averageSoreness / 3 * 30),\n            sleep: Math.max(0, 20 - sleepQuality / 10 * 20),\n            stress: stressLevel / 10 * 20,\n            volume: volumeOverreach,\n            consecutive: Math.min(10, consecutiveMRVWeeks * 5),\n            performance: performanceDecline ? 10 : 0\n        }\n    };\n}\n/**\r\n * Generate recovery session recommendations\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} options - Recovery options\r\n * @returns {Object} - Recovery session plan\r\n */ function $52d23339b7415571$var$generateRecoverySession(muscle, options = {}) {\n    const { hasIllness: hasIllness = false, sorenessLevel: sorenessLevel = 2, lastSessionRIR: lastSessionRIR = 0, preferredRecoveryType: preferredRecoveryType = 'volume' } = options;\n    const landmarks = (0, $gBc5V.default).volumeLandmarks[muscle];\n    const baseRecoveryVolume = (0, $gBc5V.default).getRecoveryVolume(muscle, hasIllness);\n    let recoveryPlan = {\n        muscle: muscle,\n        type: preferredRecoveryType,\n        sets: baseRecoveryVolume,\n        intensity: '60-70% of normal',\n        rirTarget: '3-4 RIR',\n        duration: '1 session',\n        notes: []\n    };\n    // Adjust based on soreness level\n    if (sorenessLevel >= 3) {\n        recoveryPlan.sets = Math.round(baseRecoveryVolume * 0.7);\n        recoveryPlan.intensity = '50-60% of normal';\n        recoveryPlan.rirTarget = '4-5 RIR';\n        recoveryPlan.notes.push('High soreness - very light session');\n    }\n    // Adjust for illness\n    if (hasIllness) {\n        recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\n        recoveryPlan.intensity = '40-50% of normal';\n        recoveryPlan.notes.push('Illness present - prioritize rest');\n    }\n    // Adjust based on last session intensity\n    if (lastSessionRIR <= 0.5) {\n        recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\n        recoveryPlan.notes.push('Last session was very intense');\n    }\n    // Recovery type specific adjustments\n    if (preferredRecoveryType === 'deload') {\n        recoveryPlan.sets = Math.round(landmarks.MEV * 0.5);\n        recoveryPlan.intensity = '40-50% of normal';\n        recoveryPlan.duration = '3-7 days';\n        recoveryPlan.notes.push('Full deload protocol');\n    }\n    return recoveryPlan;\n}\n/**\r\n * Monitor overreaching vs overtraining risk\r\n * @param {Object} metrics - Training metrics over time\r\n * @returns {Object} - Risk assessment\r\n */ function $52d23339b7415571$var$assessOverreachingRisk(metrics) {\n    const { weeklyPerformanceTrend: weeklyPerformanceTrend = [], weeklyFatigueTrend: weeklyFatigueTrend = [], volumeProgression: volumeProgression = [], motivationLevel: motivationLevel = 5, injuryRisk: injuryRisk = 1 // 1-10\n     } = metrics;\n    let riskScore = 0;\n    let riskFactors = [];\n    // Performance trend analysis\n    if (weeklyPerformanceTrend.length >= 2) {\n        const recentTrend = weeklyPerformanceTrend.slice(-3);\n        const isDecreasing = recentTrend.every((val, i)=>i === 0 || val <= recentTrend[i - 1]);\n        if (isDecreasing) {\n            riskScore += 20;\n            riskFactors.push('Consistent performance decline');\n        }\n    }\n    // Fatigue accumulation\n    if (weeklyFatigueTrend.length >= 2) {\n        const avgFatigue = weeklyFatigueTrend.reduce((a, b)=>a + b, 0) / weeklyFatigueTrend.length;\n        if (avgFatigue > 60) {\n            riskScore += 25;\n            riskFactors.push('High average fatigue');\n        }\n    }\n    // Volume progression rate\n    if (volumeProgression.length >= 3) {\n        const volumeIncrease = volumeProgression[volumeProgression.length - 1] - volumeProgression[0];\n        const weekSpan = volumeProgression.length;\n        const weeklyIncrease = volumeIncrease / weekSpan;\n        if (weeklyIncrease > 2) {\n            riskScore += 15;\n            riskFactors.push('Rapid volume progression');\n        }\n    }\n    // Motivation and wellbeing\n    if (motivationLevel <= 3) {\n        riskScore += 15;\n        riskFactors.push('Low motivation/enjoyment');\n    }\n    // Injury risk\n    if (injuryRisk >= 7) {\n        riskScore += 15;\n        riskFactors.push('High injury risk indicators');\n    }\n    // Current training state\n    if ((0, $gBc5V.default).consecutiveMRVWeeks >= 2) {\n        riskScore += 10;\n        riskFactors.push('Consecutive weeks at MRV');\n    }\n    // Determine risk level\n    let riskLevel = '';\n    let recommendations = [];\n    if (riskScore <= 20) {\n        riskLevel = 'low';\n        recommendations.push('Continue progressive overload');\n        recommendations.push('Monitor for early warning signs');\n    } else if (riskScore <= 40) {\n        riskLevel = 'moderate';\n        recommendations.push('Slow progression rate');\n        recommendations.push('Increase recovery focus');\n        recommendations.push('Consider planned deload');\n    } else if (riskScore <= 70) {\n        riskLevel = 'high';\n        recommendations.push('Implement deload week');\n        recommendations.push('Address lifestyle stressors');\n        recommendations.push('Reduce training frequency');\n    } else {\n        riskLevel = 'critical';\n        recommendations.push('Stop training temporarily');\n        recommendations.push('Focus on full recovery');\n        recommendations.push('Consult with coach/healthcare provider');\n    }\n    return {\n        riskScore: riskScore,\n        riskLevel: riskLevel,\n        riskFactors: riskFactors,\n        recommendations: recommendations,\n        requiresImmediateAction: riskScore > 60\n    };\n}\n/**\r\n * Calculate optimal session frequency for a muscle\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} constraints - Training constraints\r\n * @returns {Object} - Frequency recommendation\r\n */ function $52d23339b7415571$export$8d40c4b24105606b(muscle, constraints = {}) {\n    const { availableDays: availableDays = 6, currentVolume: currentVolume = null, recoveryCapacity: recoveryCapacity = 'normal', trainingAge: trainingAge = 'intermediate' // beginner, intermediate, advanced\n     } = constraints;\n    const volume = currentVolume || (0, $gBc5V.default).currentWeekSets[muscle];\n    const landmarks = (0, $gBc5V.default).volumeLandmarks[muscle];\n    // Base frequency recommendations by training age\n    const baseFrequencies = {\n        beginner: {\n            min: 2,\n            max: 3\n        },\n        intermediate: {\n            min: 2,\n            max: 4\n        },\n        advanced: {\n            min: 3,\n            max: 5\n        }\n    };\n    const ageRecommendation = baseFrequencies[trainingAge];\n    // Adjust for volume\n    let volumeFrequency = 2;\n    if (volume >= landmarks.MAV) volumeFrequency = Math.min(4, Math.ceil(volume / 6)); // ~6 sets per session max at high volumes\n    else if (volume >= landmarks.MEV) volumeFrequency = Math.min(3, Math.ceil(volume / 8)); // ~8 sets per session\n    else volumeFrequency = Math.max(2, Math.ceil(volume / 10)); // ~10 sets per session at lower volumes\n    // Adjust for recovery capacity\n    const recoveryMultipliers = {\n        low: 0.8,\n        normal: 1.0,\n        high: 1.2\n    };\n    const adjustedFrequency = Math.round(volumeFrequency * recoveryMultipliers[recoveryCapacity]);\n    // Constrain to available days and training age limits\n    const recommendedFrequency = Math.max(ageRecommendation.min, Math.min(ageRecommendation.max, adjustedFrequency, availableDays));\n    // Calculate sets per session\n    const setsPerSession = Math.ceil(volume / recommendedFrequency);\n    return {\n        muscle: muscle,\n        recommendedFrequency: recommendedFrequency,\n        setsPerSession: setsPerSession,\n        totalVolume: volume,\n        reasoning: [\n            `${volume} weekly sets`,\n            `${recoveryCapacity} recovery capacity`,\n            `${trainingAge} training age`,\n            `${availableDays} available days`\n        ],\n        alternatives: {\n            conservative: Math.max(2, recommendedFrequency - 1),\n            aggressive: Math.min(availableDays, recommendedFrequency + 1)\n        }\n    };\n}\n\n});\n\nparcelRegister(\"b3qqF\", function(module, exports) {\n\n$parcel$export(module.exports, \"validateLoad\", () => $80c479ce1d56b1ed$export$11d934779f97d76b);\n$parcel$export(module.exports, \"validateSets\", () => $80c479ce1d56b1ed$export$6a40f0625f84253c);\n$parcel$export(module.exports, \"validateMesocycleLength\", () => $80c479ce1d56b1ed$export$22b78d0144c3de8d);\n/**\r\n * Training Validation Helpers\r\n * Provides validation for loads, sets, and training parameters\r\n */ /**\r\n * Validate load percentage (1RM)\r\n * @param {number} loadPercent - Load as percentage of 1RM\r\n * @param {string} context - Training context (hypertrophy, strength, power)\r\n * @returns {Object} - Validation result\r\n */ function $80c479ce1d56b1ed$export$11d934779f97d76b(loadPercent, context = 'hypertrophy') {\n    const load = parseFloat(loadPercent);\n    if (isNaN(load) || load <= 0) return {\n        isValid: false,\n        warning: 'Load must be a positive number',\n        recommendation: 'Enter a valid load percentage'\n    };\n    // Context-specific load ranges\n    const loadRanges = {\n        hypertrophy: {\n            min: 30,\n            max: 85,\n            optimal: [\n                65,\n                80\n            ]\n        },\n        strength: {\n            min: 70,\n            max: 100,\n            optimal: [\n                85,\n                95\n            ]\n        },\n        power: {\n            min: 30,\n            max: 70,\n            optimal: [\n                40,\n                60\n            ]\n        },\n        endurance: {\n            min: 20,\n            max: 60,\n            optimal: [\n                30,\n                50\n            ]\n        }\n    };\n    const range = loadRanges[context] || loadRanges.hypertrophy;\n    let isValid = true;\n    let warning = '';\n    let recommendation = '';\n    let severity = 'normal';\n    if (load < range.min) {\n        isValid = false;\n        warning = `Load too light for ${context} (${load}% < ${range.min}%)`;\n        recommendation = `Increase to ${range.optimal[0]}-${range.optimal[1]}% for optimal ${context} adaptations`;\n        severity = 'high';\n    } else if (load > range.max) {\n        isValid = false;\n        warning = `Load too heavy for ${context} (${load}% > ${range.max}%)`;\n        recommendation = `Reduce to ${range.optimal[0]}-${range.optimal[1]}% for safer ${context} training`;\n        severity = 'high';\n    } else if (load < range.optimal[0]) {\n        warning = `Load is light for ${context} (${load}% < ${range.optimal[0]}%)`;\n        recommendation = `Consider increasing to ${range.optimal[0]}-${range.optimal[1]}% for better stimulus`;\n        severity = 'medium';\n    } else if (load > range.optimal[1]) {\n        warning = `Load is heavy for ${context} (${load}% > ${range.optimal[1]}%)`;\n        recommendation = `Consider reducing to ${range.optimal[0]}-${range.optimal[1]}% for better recovery`;\n        severity = 'medium';\n    } else recommendation = `Good load for ${context} training`;\n    return {\n        isValid: isValid,\n        load: load,\n        context: context,\n        warning: warning,\n        recommendation: recommendation,\n        severity: severity,\n        range: range,\n        isOptimal: load >= range.optimal[0] && load <= range.optimal[1]\n    };\n}\n/**\r\n * Validate RIR (Reps in Reserve)\r\n * @param {number} rir - Reps in reserve\r\n * @param {number} targetRIR - Target RIR for the session\r\n * @param {string} context - Training context\r\n * @returns {Object} - Validation result\r\n */ function $80c479ce1d56b1ed$var$validateRIR(rir, targetRIR, context = 'hypertrophy') {\n    const actualRIR = parseFloat(rir);\n    const target = parseFloat(targetRIR);\n    if (isNaN(actualRIR) || actualRIR < 0) return {\n        isValid: false,\n        warning: 'RIR must be 0 or greater',\n        recommendation: 'Enter how many more reps you could have done'\n    };\n    if (actualRIR > 10) return {\n        isValid: false,\n        warning: 'RIR too high (>10) - load likely too light',\n        recommendation: 'Increase weight significantly'\n    };\n    const deviation = Math.abs(actualRIR - target);\n    let isValid = true;\n    let warning = '';\n    let recommendation = '';\n    let severity = 'normal';\n    // Tolerance varies by context\n    const tolerances = {\n        hypertrophy: 1.0,\n        strength: 0.5,\n        power: 1.5,\n        endurance: 2.0\n    };\n    const tolerance = tolerances[context] || tolerances.hypertrophy;\n    if (deviation <= tolerance) recommendation = `On target (${actualRIR} vs ${target} RIR)`;\n    else if (actualRIR > target) {\n        const difference = actualRIR - target;\n        warning = `Too easy (${difference.toFixed(1)} RIR above target)`;\n        if (difference > 2) {\n            recommendation = 'Increase weight significantly (10-15%)';\n            severity = 'high';\n        } else {\n            recommendation = 'Increase weight moderately (5-10%)';\n            severity = 'medium';\n        }\n    } else {\n        const difference = target - actualRIR;\n        warning = `Too hard (${difference.toFixed(1)} RIR below target)`;\n        if (difference > 2) {\n            recommendation = 'Reduce weight significantly (10-15%)';\n            severity = 'high';\n        } else {\n            recommendation = 'Reduce weight slightly (5-10%)';\n            severity = 'medium';\n        }\n    }\n    return {\n        isValid: isValid,\n        actualRIR: actualRIR,\n        targetRIR: target,\n        deviation: deviation,\n        warning: warning,\n        recommendation: recommendation,\n        severity: severity,\n        isOnTarget: deviation <= tolerance\n    };\n}\n/**\r\n * Validate set count within volume landmarks\r\n * @param {number} sets - Proposed set count\r\n * @param {Object} landmarks - Volume landmarks {MV, MEV, MAV, MRV}\r\n * @param {boolean} allowOverreach - Allow sets above MRV\r\n * @returns {Object} - Validation result\r\n */ function $80c479ce1d56b1ed$export$6a40f0625f84253c(sets, landmarks, allowOverreach = false) {\n    const setCount = parseInt(sets, 10);\n    if (isNaN(setCount) || setCount < 0) return {\n        isValid: false,\n        warning: 'Set count must be 0 or greater',\n        recommendation: 'Enter a valid number of sets'\n    };\n    const { MV: MV = 0, MEV: MEV, MAV: MAV, MRV: MRV } = landmarks;\n    let isValid = true;\n    let warning = '';\n    let recommendation = '';\n    let severity = 'normal';\n    let zone = '';\n    if (setCount < MV) {\n        zone = 'below-maintenance';\n        warning = `Below maintenance volume (${setCount} < ${MV})`;\n        recommendation = 'Increase sets for minimal stimulus';\n        severity = 'high';\n    } else if (setCount < MEV) {\n        zone = 'maintenance';\n        warning = `In maintenance zone (${setCount} < ${MEV})`;\n        recommendation = 'Increase sets for growth stimulus';\n        severity = 'medium';\n    } else if (setCount <= MAV) {\n        zone = 'optimal';\n        recommendation = `Optimal volume zone (${MEV}-${MAV} sets)`;\n    } else if (setCount <= MRV) {\n        zone = 'high';\n        warning = `High volume zone (${setCount} approaching ${MRV})`;\n        recommendation = 'Monitor recovery closely';\n        severity = 'medium';\n    } else {\n        zone = 'maximum';\n        if (!allowOverreach) {\n            isValid = false;\n            warning = `Above maximum recoverable volume (${setCount} > ${MRV})`;\n            recommendation = 'Reduce sets or plan deload';\n            severity = 'high';\n        } else {\n            warning = `Overreaching territory (${setCount} > ${MRV})`;\n            recommendation = 'Short-term only - deload soon';\n            severity = 'high';\n        }\n    }\n    return {\n        isValid: isValid,\n        sets: setCount,\n        landmarks: landmarks,\n        zone: zone,\n        warning: warning,\n        recommendation: recommendation,\n        severity: severity,\n        percentage: Math.round(setCount / MRV * 100)\n    };\n}\n/**\r\n * Validate training frequency\r\n * @param {number} frequency - Sessions per week\r\n * @param {number} weeklyVolume - Total weekly sets\r\n * @param {string} muscleGroup - Muscle group name\r\n * @returns {Object} - Validation result\r\n */ function $80c479ce1d56b1ed$var$validateFrequency(frequency, weeklyVolume, muscleGroup = '') {\n    const freq = parseInt(frequency, 10);\n    const volume = parseInt(weeklyVolume, 10);\n    if (isNaN(freq) || freq < 1) return {\n        isValid: false,\n        warning: 'Frequency must be at least 1 session per week',\n        recommendation: 'Train each muscle at least once per week'\n    };\n    if (isNaN(volume) || volume < 0) return {\n        isValid: false,\n        warning: 'Weekly volume must be specified',\n        recommendation: 'Enter total weekly sets'\n    };\n    const setsPerSession = volume / freq;\n    let isValid = true;\n    let warning = '';\n    let recommendation = '';\n    let severity = 'normal';\n    // General guidelines for sets per session\n    if (setsPerSession > 20) {\n        isValid = false;\n        warning = `Too many sets per session (${setsPerSession.toFixed(1)})`;\n        recommendation = 'Increase frequency or reduce volume';\n        severity = 'high';\n    } else if (setsPerSession > 12) {\n        warning = `High sets per session (${setsPerSession.toFixed(1)})`;\n        recommendation = 'Consider increasing frequency';\n        severity = 'medium';\n    } else if (setsPerSession < 2 && volume >= 6) {\n        warning = `Very low sets per session (${setsPerSession.toFixed(1)})`;\n        recommendation = 'Consider reducing frequency';\n        severity = 'medium';\n    } else recommendation = `Good distribution (${setsPerSession.toFixed(1)} sets/session)`;\n    // Frequency-specific advice\n    let frequencyAdvice = '';\n    if (freq === 1) frequencyAdvice = 'Once weekly - ensure high quality';\n    else if (freq === 2) frequencyAdvice = 'Twice weekly - good for most goals';\n    else if (freq === 3) frequencyAdvice = 'Three times weekly - high frequency';\n    else if (freq >= 4) frequencyAdvice = 'Very high frequency - monitor recovery';\n    return {\n        isValid: isValid,\n        frequency: freq,\n        weeklyVolume: volume,\n        setsPerSession: Math.round(setsPerSession * 10) / 10,\n        warning: warning,\n        recommendation: recommendation,\n        frequencyAdvice: frequencyAdvice,\n        severity: severity,\n        muscleGroup: muscleGroup\n    };\n}\n/**\r\n * Validate mesocycle length\r\n * @param {number} weeks - Mesocycle length in weeks\r\n * @param {string} goal - Training goal\r\n * @returns {Object} - Validation result\r\n */ function $80c479ce1d56b1ed$export$22b78d0144c3de8d(weeks, goal = 'hypertrophy') {\n    const mesoLength = parseInt(weeks, 10);\n    if (isNaN(mesoLength) || mesoLength < 1) return {\n        isValid: false,\n        warning: 'Mesocycle must be at least 1 week',\n        recommendation: 'Enter a valid mesocycle length'\n    };\n    // Goal-specific recommendations\n    const recommendations = {\n        hypertrophy: {\n            min: 3,\n            max: 6,\n            optimal: 4\n        },\n        strength: {\n            min: 2,\n            max: 8,\n            optimal: 4\n        },\n        power: {\n            min: 2,\n            max: 4,\n            optimal: 3\n        },\n        endurance: {\n            min: 4,\n            max: 12,\n            optimal: 6\n        }\n    };\n    const rec = recommendations[goal] || recommendations.hypertrophy;\n    let isValid = true;\n    let warning = '';\n    let recommendation = '';\n    let severity = 'normal';\n    if (mesoLength < rec.min) {\n        warning = `Short mesocycle for ${goal} (${mesoLength} < ${rec.min} weeks)`;\n        recommendation = `Consider ${rec.optimal} weeks for better ${goal} adaptations`;\n        severity = 'medium';\n    } else if (mesoLength > rec.max) {\n        warning = `Long mesocycle for ${goal} (${mesoLength} > ${rec.max} weeks)`;\n        recommendation = `Consider ${rec.optimal} weeks to prevent overreaching`;\n        severity = 'medium';\n    } else if (mesoLength === rec.optimal) recommendation = `Optimal length for ${goal} training`;\n    else recommendation = `Good length for ${goal} training`;\n    return {\n        isValid: isValid,\n        weeks: mesoLength,\n        goal: goal,\n        warning: warning,\n        recommendation: recommendation,\n        severity: severity,\n        isOptimal: mesoLength === rec.optimal,\n        range: rec\n    };\n}\n/**\r\n * Validate input ranges for UI components\r\n * @param {*} value - Input value\r\n * @param {Object} constraints - Validation constraints\r\n * @returns {Object} - Validation result\r\n */ function $80c479ce1d56b1ed$var$validateInputRange(value, constraints) {\n    const { type: type = 'number', min: min = null, max: max = null, step: step = null, required: required = false, customValidator: customValidator = null } = constraints;\n    // Check if required\n    if (required && (value === null || value === undefined || value === '')) return {\n        isValid: false,\n        warning: 'This field is required',\n        recommendation: 'Please enter a value'\n    };\n    // Type validation\n    if (type === 'number') {\n        const num = parseFloat(value);\n        if (isNaN(num)) return {\n            isValid: false,\n            warning: 'Must be a valid number',\n            recommendation: 'Enter a numeric value'\n        };\n        if (min !== null && num < min) return {\n            isValid: false,\n            warning: `Must be at least ${min}`,\n            recommendation: `Enter a value \\u{2265} ${min}`\n        };\n        if (max !== null && num > max) return {\n            isValid: false,\n            warning: `Must be at most ${max}`,\n            recommendation: `Enter a value \\u{2264} ${max}`\n        };\n        if (step !== null && num * 100 % (step * 100) !== 0) return {\n            isValid: false,\n            warning: `Must be in increments of ${step}`,\n            recommendation: `Use multiples of ${step}`\n        };\n    }\n    // Custom validation\n    if (customValidator && typeof customValidator === 'function') {\n        const customResult = customValidator(value);\n        if (!customResult.isValid) return customResult;\n    }\n    return {\n        isValid: true,\n        value: value,\n        recommendation: 'Valid input'\n    };\n}\n/**\r\n * Create comprehensive validation summary\r\n * @param {Object} formData - Complete form data\r\n * @param {Object} validationRules - Validation rules for each field\r\n * @returns {Object} - Comprehensive validation result\r\n */ function $80c479ce1d56b1ed$var$validateTrainingSession(formData, validationRules = {}) {\n    const results = {};\n    const errors = [];\n    const warnings = [];\n    Object.keys(formData).forEach((field)=>{\n        const value = formData[field];\n        const rules = validationRules[field];\n        if (rules) {\n            let result;\n            switch(rules.type){\n                case 'load':\n                    result = $80c479ce1d56b1ed$export$11d934779f97d76b(value, rules.context);\n                    break;\n                case 'rir':\n                    result = $80c479ce1d56b1ed$var$validateRIR(value, rules.target, rules.context);\n                    break;\n                case 'sets':\n                    result = $80c479ce1d56b1ed$export$6a40f0625f84253c(value, rules.landmarks, rules.allowOverreach);\n                    break;\n                case 'frequency':\n                    result = $80c479ce1d56b1ed$var$validateFrequency(value, rules.volume, rules.muscle);\n                    break;\n                case 'meso':\n                    result = $80c479ce1d56b1ed$export$22b78d0144c3de8d(value, rules.goal);\n                    break;\n                default:\n                    result = $80c479ce1d56b1ed$var$validateInputRange(value, rules);\n            }\n            results[field] = result;\n            if (!result.isValid) errors.push(`${field}: ${result.warning}`);\n            else if (result.warning) warnings.push(`${field}: ${result.warning}`);\n        }\n    });\n    return {\n        isValid: errors.length === 0,\n        hasWarnings: warnings.length > 0,\n        errors: errors,\n        warnings: warnings,\n        fieldResults: results,\n        summary: errors.length === 0 ? warnings.length === 0 ? 'All inputs valid' : 'Valid with warnings' : `${errors.length} validation error(s)`\n    };\n}\n\n});\n\n\n//# sourceMappingURL=ProgramDesignWorkspace.a153faa7.js.map\n","/**\r\n * Chart Management UI\r\n * Handles all chart rendering and interactions\r\n */\r\n\r\nimport trainingState from '../core/trainingState.js';\r\n\r\nlet weeklyChart = null;\r\nconst muscles = Object.keys(trainingState.volumeLandmarks);\r\n\r\n/**\r\n * Initialize the weekly volume chart\r\n */\r\nfunction initChart() {\r\n  const canvas = document.getElementById('weeklyChart');\r\n  if (!canvas) {\r\n    console.error('Chart canvas not found');\r\n    return null;\r\n  }\r\n  \r\n  const ctx = canvas.getContext('2d');\r\n  if (!ctx) {\r\n    console.error('Cannot get canvas context');\r\n    return null;\r\n  }\r\n  \r\n  if (typeof Chart === 'undefined') {\r\n    console.error('Chart.js not loaded');\r\n    return null;\r\n  }\r\n\r\n  const chartData = muscles.map(muscle => trainingState.currentWeekSets[muscle] || 0);\r\n  const backgroundColors = muscles.map(muscle => trainingState.getVolumeColor(muscle));\r\n    weeklyChart = new Chart(ctx, {\r\n    type: 'bar',\r\n    data: {\r\n      labels: muscles,\r\n      datasets: [{\r\n        label: 'Current Sets',\r\n        data: chartData,\r\n        backgroundColor: backgroundColors,\r\n        borderColor: backgroundColors.map(color => color.replace('0.6', '1')),\r\n        borderWidth: 2\r\n      }, {\r\n        label: 'MEV',\r\n        data: muscles.map(muscle => trainingState.volumeLandmarks[muscle].MEV),\r\n        type: 'line',\r\n        borderColor: 'rgba(255, 255, 0, 0.8)',\r\n        backgroundColor: 'transparent',\r\n        borderWidth: 2,\r\n        pointRadius: 3,\r\n        pointBackgroundColor: 'rgba(255, 255, 0, 1)',\r\n        borderDash: [5, 5]\r\n      }, {\r\n        label: 'MRV',\r\n        data: muscles.map(muscle => trainingState.volumeLandmarks[muscle].MRV),\r\n        type: 'line',\r\n        borderColor: 'rgba(255, 0, 0, 0.8)',\r\n        backgroundColor: 'transparent',\r\n        borderWidth: 2,\r\n        pointRadius: 3,\r\n        pointBackgroundColor: 'rgba(255, 0, 0, 1)',\r\n        borderDash: [10, 5]\r\n      }]\r\n    },\r\n    options: {\r\n      responsive: true,\r\n      maintainAspectRatio: false,\r\n      plugins: {\r\n        legend: {\r\n          labels: {\r\n            color: '#fff'\r\n          }\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            afterLabel: function(context) {\r\n              const muscle = context.label;\r\n              const sets = context.parsed.y;\r\n              const landmarks = trainingState.volumeLandmarks[muscle];\r\n              const status = trainingState.getVolumeStatus(muscle, sets);\r\n              \r\n              return [\r\n                `Status: ${status}`,\r\n                `MEV: ${landmarks.MEV} | MRV: ${landmarks.MRV}`,\r\n                `Target RIR: ${trainingState.getTargetRIR()}`\r\n              ];\r\n            }\r\n          }\r\n        }\r\n      },      scales: {\r\n        y: {\r\n          beginAtZero: true,\r\n          grid: {\r\n            color: 'rgba(255, 255, 255, 0.1)'\r\n          },\r\n          ticks: {\r\n            color: '#fff',\r\n            stepSize: 5  // Show every 5 sets on Y-axis\r\n          }\r\n        },\r\n        x: {\r\n          grid: {\r\n            color: 'rgba(255, 255, 255, 0.1)'\r\n          },\r\n          ticks: {\r\n            color: '#fff'\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n  \r\n  return weeklyChart;\r\n}\r\n\r\n/**\r\n * Update chart with current data\r\n */\r\nfunction updateChart() {\r\n  if (!weeklyChart) return;\r\n  \r\n  const newData = muscles.map(muscle => trainingState.currentWeekSets[muscle] || 0);\r\n  const newColors = muscles.map(muscle => trainingState.getVolumeColor(muscle));\r\n  \r\n  // Update current sets data\r\n  weeklyChart.data.datasets[0].data = newData;\r\n  weeklyChart.data.datasets[0].backgroundColor = newColors;\r\n  weeklyChart.data.datasets[0].borderColor = newColors.map(color => color.replace('0.6', '1'));\r\n  \r\n  // Update landmark lines\r\n  weeklyChart.data.datasets[1].data = muscles.map(muscle => trainingState.volumeLandmarks[muscle].MEV);\r\n  weeklyChart.data.datasets[2].data = muscles.map(muscle => trainingState.volumeLandmarks[muscle].MRV);\r\n  \r\n  weeklyChart.update();\r\n}\r\n\r\n/**\r\n * Reset chart data\r\n */\r\nfunction resetChart() {\r\n  muscles.forEach(muscle => {\r\n    trainingState.updateWeeklySets(muscle, trainingState.volumeLandmarks[muscle].MEV);\r\n  });\r\n  updateChart();\r\n}\r\n\r\n/**\r\n * Show deload visualization\r\n */\r\nfunction showDeloadVisualization() {\r\n  if (!weeklyChart) return;\r\n  \r\n  // Temporarily show 50% volume\r\n  const deloadData = muscles.map(muscle => \r\n    Math.round(trainingState.volumeLandmarks[muscle].MEV * 0.5)\r\n  );\r\n  \r\n  weeklyChart.data.datasets[0].data = deloadData;\r\n  weeklyChart.data.datasets[0].backgroundColor = muscles.map(() => 'rgba(100, 100, 100, 0.6)');\r\n  weeklyChart.update();\r\n  \r\n  // Reset after 3 seconds\r\n  setTimeout(() => {\r\n    updateChart();  }, 3000);\r\n}\r\n\r\n/**\r\n * Add volume landmarks overlay to chart\r\n */\r\nfunction addVolumeLandmarks() {\r\n  if (!weeklyChart) return;\r\n  \r\n  // Landmarks are already built into the chart\r\n  // This function maintains compatibility with existing code\r\n  console.log('Volume landmarks are permanently displayed on chart');\r\n}\r\n\r\n/**\r\n * Export chart as image for reports\r\n */\r\nfunction exportChartImage() {\r\n  if (!weeklyChart) {\r\n    console.warn('No chart available for export');\r\n    return null;\r\n  }\r\n  \r\n  try {\r\n    // Get chart as base64 image\r\n    const base64Image = weeklyChart.toBase64Image('image/png', 1);\r\n    \r\n    // Create download link\r\n    const link = document.createElement('a');\r\n    link.download = `workout-volume-chart-week-${trainingState.weekNo}.png`;\r\n    link.href = base64Image;\r\n    \r\n    // Trigger download\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    document.body.removeChild(link);\r\n    \r\n    // Show success message\r\n    const notification = document.createElement('div');\r\n    notification.style.cssText = `\r\n      position: fixed;\r\n      top: 20px;\r\n      right: 20px;\r\n      background: #4CAF50;\r\n      color: white;\r\n      padding: 12px 20px;\r\n      border-radius: 8px;\r\n      z-index: 10000;\r\n      font-weight: 600;\r\n    `;\r\n    notification.textContent = 'Chart exported successfully!';\r\n    document.body.appendChild(notification);\r\n    \r\n    setTimeout(() => {\r\n      document.body.removeChild(notification);\r\n    }, 3000);\r\n    \r\n    return base64Image;\r\n  } catch (e) {\r\n    console.error('Chart export failed:', e);\r\n    \r\n    // Show error message\r\n    const notification = document.createElement('div');\r\n    notification.style.cssText = `\r\n      position: fixed;\r\n      top: 20px;\r\n      right: 20px;\r\n      background: #f44336;\r\n      color: white;\r\n      padding: 12px 20px;\r\n      border-radius: 8px;\r\n      z-index: 10000;\r\n      font-weight: 600;\r\n    `;\r\n    notification.textContent = 'Export failed. Please try again.';\r\n    document.body.appendChild(notification);\r\n    \r\n    setTimeout(() => {\r\n      document.body.removeChild(notification);\r\n    }, 3000);\r\n    \r\n    return null;\r\n  }\r\n}\r\n\r\n// --- consolidated exports ---\r\nexport {\r\n  initChart,\r\n  updateChart,\r\n  resetChart,\r\n  addVolumeLandmarks,\r\n  exportChartImage,\r\n  showDeloadVisualization,\r\n  weeklyChart\r\n};\r\n","/**\r\n * TrainingState Singleton - Renaissance Periodization Implementation\r\n * Manages all training state including volume landmarks, meso progression, and deload logic\r\n */\r\n\r\nclass TrainingState {\r\n  constructor() {\r\n    if (TrainingState.instance) {\r\n      return TrainingState.instance;\r\n    }\r\n\r\n    // Core RP Volume Landmarks (defaults from RP literature)\r\n    this.volumeLandmarks = {\r\n      'Chest': { MV: 4, MEV: 8, MAV: 16, MRV: 22 },\r\n      'Back': { MV: 6, MEV: 10, MAV: 20, MRV: 25 },\r\n      'Quads': { MV: 6, MEV: 10, MAV: 20, MRV: 25 },\r\n      'Hamstrings': { MV: 4, MEV: 6, MAV: 16, MRV: 20 },\r\n      'Shoulders': { MV: 4, MEV: 8, MAV: 16, MRV: 20 },\r\n      'Biceps': { MV: 4, MEV: 6, MAV: 14, MRV: 20 },\r\n      'Triceps': { MV: 4, MEV: 6, MAV: 14, MRV: 18 },\r\n      'Calves': { MV: 6, MEV: 8, MAV: 16, MRV: 22 },\r\n      'Abs': { MV: 0, MEV: 6, MAV: 16, MRV: 25 },\r\n      'Forearms': { MV: 2, MEV: 4, MAV: 10, MRV: 16 },\r\n      'Neck': { MV: 0, MEV: 2, MAV: 8, MRV: 12 },\r\n      'Traps': { MV: 2, MEV: 4, MAV: 12, MRV: 16 }\r\n    };\r\n\r\n    // Training progression state\r\n    this.weekNo = 1;\r\n    this.mesoLen = 4;\r\n    this.blockNo = 1;\r\n    this.deloadPhase = false;\r\n    this.resensitizationPhase = false;\r\n\r\n    // Current week data\r\n    this.currentWeekSets = {};\r\n    this.lastWeekSets = {};\r\n    \r\n    // Initialize current week sets at MEV\r\n    Object.keys(this.volumeLandmarks).forEach(muscle => {\r\n      this.currentWeekSets[muscle] = this.volumeLandmarks[muscle].MEV;\r\n      this.lastWeekSets[muscle] = this.volumeLandmarks[muscle].MEV;\r\n    });\r\n\r\n    // Performance tracking for deload detection\r\n    this.consecutiveMRVWeeks = 0;\r\n    this.recoverySessionsThisWeek = 0;\r\n    this.totalMusclesNeedingRecovery = 0;\r\n\r\n    TrainingState.instance = this;\r\n    this.loadState();\r\n  }\r\n  // Calculate target RIR based on meso progression\r\n  getTargetRIR() {\r\n    const startRIR = 3.0;\r\n    const endRIR = 0.5;\r\n    const progressionRate = (startRIR - endRIR) / (this.mesoLen - 1);\r\n    const targetRIR = startRIR - (progressionRate * (this.weekNo - 1));\r\n    return Math.max(endRIR, Math.min(startRIR, targetRIR));\r\n  }\r\n\r\n  // Get volume status for a muscle\r\n  getVolumeStatus(muscle, sets = null) {\r\n    const currentSets = sets !== null ? sets : this.currentWeekSets[muscle];\r\n    const landmarks = this.volumeLandmarks[muscle];\r\n    \r\n    if (currentSets < landmarks.MV) return 'under-minimum';\r\n    if (currentSets < landmarks.MEV) return 'maintenance';\r\n    if (currentSets < landmarks.MAV) return 'optimal';\r\n    if (currentSets < landmarks.MRV) return 'high';\r\n    return 'maximum';\r\n  }\r\n\r\n  // Get volume zone color for charting\r\n  getVolumeColor(muscle, sets = null) {\r\n    const status = this.getVolumeStatus(muscle, sets);\r\n    const colors = {\r\n      'under-minimum': '#ff4444',  // Red\r\n      'maintenance': '#ffaa00',    // Orange\r\n      'optimal': '#44ff44',        // Green\r\n      'high': '#ffff44',           // Yellow\r\n      'maximum': '#ff4444'         // Red\r\n    };\r\n    return colors[status];\r\n  }\r\n\r\n  // Update weekly sets for a muscle\r\n  updateWeeklySets(muscle, sets) {\r\n    this.currentWeekSets[muscle] = Math.max(0, sets);\r\n    this.saveState();\r\n  }\r\n\r\n  // Add sets to a muscle\r\n  addSets(muscle, additionalSets) {\r\n    this.currentWeekSets[muscle] += additionalSets;\r\n    this.currentWeekSets[muscle] = Math.max(0, this.currentWeekSets[muscle]);\r\n    this.saveState();\r\n  }\r\n\r\n  // Check if deload is needed\r\n  shouldDeload() {\r\n    // Check 1: Consecutive weeks at MRV\r\n    if (this.consecutiveMRVWeeks >= 2) return true;\r\n    \r\n    // Check 2: Most muscles need recovery\r\n    const totalMuscles = Object.keys(this.volumeLandmarks).length;\r\n    if (this.totalMusclesNeedingRecovery >= Math.ceil(totalMuscles / 2)) return true;\r\n    \r\n    // Check 3: End of meso\r\n    if (this.weekNo >= this.mesoLen) return true;\r\n    \r\n    return false;\r\n  }\r\n\r\n  // Check if resensitization is needed (every 3-6 mesos)\r\n  shouldResensitize() {\r\n    return this.blockNo % 4 === 0; // Every 4 blocks (adjustable)\r\n  }\r\n\r\n  // Start deload phase\r\n  startDeload() {\r\n    this.deloadPhase = true;\r\n    // Reduce all sets to 50% of MEV\r\n    Object.keys(this.volumeLandmarks).forEach(muscle => {\r\n      const deloadSets = Math.round(this.volumeLandmarks[muscle].MEV * 0.5);\r\n      this.currentWeekSets[muscle] = deloadSets;\r\n    });\r\n    this.saveState();\r\n  }\r\n\r\n  // Start resensitization phase\r\n  startResensitization() {\r\n    this.resensitizationPhase = true;\r\n    // Set all muscles to MV\r\n    Object.keys(this.volumeLandmarks).forEach(muscle => {\r\n      this.currentWeekSets[muscle] = this.volumeLandmarks[muscle].MV;\r\n    });\r\n    this.saveState();\r\n  }\r\n\r\n  // Progress to next week\r\n  nextWeek() {\r\n    // Store last week's data\r\n    this.lastWeekSets = { ...this.currentWeekSets };\r\n    \r\n    // Check for MRV breach\r\n    const mrvBreaches = Object.keys(this.volumeLandmarks).filter(muscle => \r\n      this.currentWeekSets[muscle] >= this.volumeLandmarks[muscle].MRV\r\n    );\r\n    \r\n    if (mrvBreaches.length > 0) {\r\n      this.consecutiveMRVWeeks++;\r\n    } else {\r\n      this.consecutiveMRVWeeks = 0;\r\n    }\r\n\r\n    // Progress week\r\n    this.weekNo++;\r\n    \r\n    // Check for meso completion\r\n    if (this.weekNo > this.mesoLen) {\r\n      this.weekNo = 1;\r\n      this.blockNo++;\r\n      this.consecutiveMRVWeeks = 0;\r\n    }\r\n\r\n    // Reset weekly counters\r\n    this.recoverySessionsThisWeek = 0;\r\n    this.totalMusclesNeedingRecovery = 0;\r\n\r\n    this.saveState();\r\n  }\r\n\r\n  // Reset week (for testing/corrections)\r\n  resetWeek() {\r\n    Object.keys(this.volumeLandmarks).forEach(muscle => {\r\n      this.currentWeekSets[muscle] = this.volumeLandmarks[muscle].MEV;\r\n    });\r\n    this.saveState();\r\n  }\r\n\r\n  // Update volume landmarks for a muscle\r\n  updateVolumeLandmarks(muscle, landmarks) {\r\n    this.volumeLandmarks[muscle] = { ...this.volumeLandmarks[muscle], ...landmarks };\r\n    this.saveState();\r\n  }\r\n\r\n  // Calculate recovery volume\r\n  getRecoveryVolume(muscle, hasIllness = false) {\r\n    const landmarks = this.volumeLandmarks[muscle];\r\n    const midpoint = Math.round((landmarks.MEV + landmarks.MRV) / 2);\r\n    const adjustment = hasIllness ? 2 : 1;\r\n    const recoveryVolume = midpoint - adjustment;\r\n    return Math.max(recoveryVolume, Math.ceil(landmarks.MEV * 0.5));\r\n  }\r\n\r\n  // Save state to localStorage\r\n  saveState() {\r\n    const state = {\r\n      volumeLandmarks: this.volumeLandmarks,\r\n      weekNo: this.weekNo,\r\n      mesoLen: this.mesoLen,\r\n      blockNo: this.blockNo,\r\n      deloadPhase: this.deloadPhase,\r\n      resensitizationPhase: this.resensitizationPhase,\r\n      currentWeekSets: this.currentWeekSets,\r\n      lastWeekSets: this.lastWeekSets,\r\n      consecutiveMRVWeeks: this.consecutiveMRVWeeks,\r\n      recoverySessionsThisWeek: this.recoverySessionsThisWeek,\r\n      totalMusclesNeedingRecovery: this.totalMusclesNeedingRecovery\r\n    };\r\n    \r\n    localStorage.setItem('rp-training-state', JSON.stringify(state));\r\n  }\r\n\r\n  // Load state from localStorage\r\n  loadState() {\r\n    const saved = localStorage.getItem('rp-training-state');\r\n    if (saved) {\r\n      try {\r\n        const state = JSON.parse(saved);\r\n        Object.assign(this, state);\r\n      } catch (e) {\r\n        console.warn('Failed to load training state, using defaults');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Migrate legacy localStorage data\r\n  migrateLegacyData() {\r\n    const muscles = Object.keys(this.volumeLandmarks);\r\n    let hasLegacyData = false;\r\n\r\n    muscles.forEach(muscle => {\r\n      // Check for old format keys\r\n      const oldKey = `week-1-${muscle}`;\r\n      const oldValue = localStorage.getItem(oldKey);\r\n      \r\n      if (oldValue) {\r\n        this.currentWeekSets[muscle] = parseInt(oldValue, 10);\r\n        localStorage.removeItem(oldKey);\r\n        hasLegacyData = true;\r\n      }\r\n\r\n      // Migrate MEV/MRV settings\r\n      const mevKey = `${muscle}-MEV`;\r\n      const mrvKey = `${muscle}-MRV`;\r\n      const mevValue = localStorage.getItem(mevKey);\r\n      const mrvValue = localStorage.getItem(mrvKey);\r\n\r\n      if (mevValue || mrvValue) {\r\n        this.volumeLandmarks[muscle] = {\r\n          ...this.volumeLandmarks[muscle],\r\n          MEV: mevValue ? parseInt(mevValue, 10) : this.volumeLandmarks[muscle].MEV,\r\n          MRV: mrvValue ? parseInt(mrvValue, 10) : this.volumeLandmarks[muscle].MRV\r\n        };\r\n        if (mevValue) localStorage.removeItem(mevKey);\r\n        if (mrvValue) localStorage.removeItem(mrvKey);\r\n        hasLegacyData = true;\r\n      }\r\n    });\r\n\r\n    if (hasLegacyData) {\r\n      this.saveState();\r\n      console.log('Legacy data migrated to new RP training state');\r\n    }\r\n  }\r\n\r\n  // Get current state summary\r\n  getStateSummary() {\r\n    return {\r\n      week: this.weekNo,\r\n      meso: this.mesoLen,\r\n      block: this.blockNo,\r\n      targetRIR: this.getTargetRIR(),\r\n      deloadRecommended: this.shouldDeload(),\r\n      resensitizationRecommended: this.shouldResensitize(),\r\n      currentPhase: this.deloadPhase ? 'deload' : \r\n                   this.resensitizationPhase ? 'resensitization' : 'accumulation'\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nconst trainingState = new TrainingState();\r\nexport default trainingState;\r\n\r\n// Also make available globally for legacy compatibility\r\nif (typeof window !== 'undefined') {\r\n  window.trainingState = trainingState;\r\n}\r\n","/**\r\n * Renaissance Periodization Volume Algorithms\r\n * Implements RP Table 2.2 (MEV Stimulus Estimator) and Table 2.3 (Set Progression Algorithm)\r\n */\r\n\r\nimport trainingState from '../core/trainingState.js';\r\n\r\n/**\r\n * RP Table 2.2: MEV Stimulus Estimator\r\n * Scores stimulus quality based on mind-muscle connection, pump, and disruption\r\n * @param {Object} feedback - {mmc: 0-3, pump: 0-3, disruption: 0-3}\r\n * @returns {Object} - {score: 0-9, advice: string, action: string}\r\n */\r\nfunction scoreStimulus({ mmc, pump, disruption }) {\r\n  // Validate inputs\r\n  const clamp = (val, min, max) => Math.max(min, Math.min(max, val));\r\n  const clampedMmc = clamp(mmc, 0, 3);\r\n  const clampedPump = clamp(pump, 0, 3);\r\n  const clampedDisruption = clamp(disruption, 0, 3);\r\n  \r\n  const totalScore = clampedMmc + clampedPump + clampedDisruption;\r\n  \r\n  let advice, action, setChange;\r\n  \r\n  if (totalScore <= 3) {\r\n    advice = `Stimulus too low (${totalScore}/9)  Add 2 sets next session`;\r\n    action = 'add_sets';\r\n    setChange = 2;\r\n  } else if (totalScore <= 6) {\r\n    advice = `Stimulus adequate (${totalScore}/9)  Keep sets the same`;\r\n    action = 'maintain';\r\n    setChange = 0;\r\n  } else {\r\n    advice = `Stimulus excessive (${totalScore}/9)  Remove 1-2 sets next session`;\r\n    action = 'reduce_sets';\r\n    setChange = -1;\r\n  }\r\n  \r\n  return {\r\n    score: totalScore,\r\n    advice,\r\n    action,\r\n    setChange,\r\n    breakdown: {\r\n      mmc: clampedMmc,\r\n      pump: clampedPump,\r\n      disruption: clampedDisruption\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * RP Table 2.3: Set Progression Algorithm\r\n * Matrix lookup based on soreness level and performance vs last session\r\n * @param {number} soreness - 0-3 (0=none, 1=mild, 2=moderate, 3=high)\r\n * @param {number} performance - 0-3 (0=worse, 1=same, 2=better, 3=much better)\r\n * @returns {Object} - {advice: string, action: string, setChange: number}\r\n */\r\nfunction setProgressionAlgorithm(soreness, performance) {\r\n  // Clamp inputs to valid ranges\r\n  const clamp = (val, min, max) => Math.max(min, Math.min(max, val));\r\n  const s = clamp(soreness, 0, 3);\r\n  const p = clamp(performance, 0, 3);\r\n  \r\n  // RP Set Progression Matrix [soreness][performance]\r\n  const progressionMatrix = [\r\n    // Soreness 0 (None)\r\n    [\r\n      { advice: \"Add 1 set next session\", action: \"add_sets\", setChange: 1 },      // Performance 0 (worse)\r\n      { advice: \"Add 2 sets next session\", action: \"add_sets\", setChange: 2 },     // Performance 1 (same)\r\n      { advice: \"Add 2-3 sets next session\", action: \"add_sets\", setChange: 2 },   // Performance 2 (better)\r\n      { advice: \"Add 2-3 sets next session\", action: \"add_sets\", setChange: 3 }    // Performance 3 (much better)\r\n    ],\r\n    // Soreness 1 (Mild)\r\n    [\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 },  // Performance 0\r\n      { advice: \"Add 1 set next session\", action: \"add_sets\", setChange: 1 },      // Performance 1\r\n      { advice: \"Add 2 sets next session\", action: \"add_sets\", setChange: 2 },     // Performance 2\r\n      { advice: \"Add 2-3 sets next session\", action: \"add_sets\", setChange: 2 }    // Performance 3\r\n    ],\r\n    // Soreness 2 (Moderate)\r\n    [\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 0\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 },  // Performance 1\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 },  // Performance 2\r\n      { advice: \"Add 1 set next session\", action: \"add_sets\", setChange: 1 }       // Performance 3\r\n    ],\r\n    // Soreness 3 (High)\r\n    [\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 0\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 1\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 2\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 }   // Performance 3\r\n    ]\r\n  ];\r\n  \r\n  return progressionMatrix[s][p];\r\n}\r\n\r\n/**\r\n * Analyze current volume status relative to landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} currentSets - Current weekly sets (optional, uses state if not provided)\r\n * @returns {Object} - Volume analysis\r\n */\r\nfunction analyzeVolumeStatus(muscle, currentSets = null) {\r\n  const sets = currentSets !== null ? currentSets : trainingState.currentWeekSets[muscle];\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  \r\n  if (!landmarks) {\r\n    throw new Error(`Unknown muscle group: ${muscle}`);\r\n  }\r\n  \r\n  const status = trainingState.getVolumeStatus(muscle, sets);\r\n  const percentage = (sets / landmarks.MRV) * 100;\r\n  \r\n  let recommendation = '';\r\n  let urgency = 'normal';\r\n  \r\n  switch (status) {\r\n    case 'under-minimum':\r\n      recommendation = `Below MV (${landmarks.MV}). Increase volume significantly.`;\r\n      urgency = 'high';\r\n      break;\r\n    case 'maintenance':\r\n      recommendation = `In maintenance zone (${landmarks.MV}-${landmarks.MEV}). Consider increasing for growth.`;\r\n      urgency = 'low';\r\n      break;\r\n    case 'optimal':\r\n      recommendation = `In optimal zone (${landmarks.MEV}-${landmarks.MAV}). Continue progressive overload.`;\r\n      urgency = 'normal';\r\n      break;\r\n    case 'high':\r\n      recommendation = `High volume zone (${landmarks.MAV}-${landmarks.MRV}). Monitor recovery closely.`;\r\n      urgency = 'medium';\r\n      break;\r\n    case 'maximum':\r\n      recommendation = `At/above MRV (${landmarks.MRV}). Deload recommended.`;\r\n      urgency = 'high';\r\n      break;\r\n  }\r\n  \r\n  return {\r\n    muscle,\r\n    currentSets: sets,\r\n    landmarks,\r\n    status,\r\n    percentage: Math.round(percentage),\r\n    recommendation,\r\n    urgency,\r\n    color: trainingState.getVolumeColor(muscle, sets)\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate recovery session volume\r\n * @param {string} muscle - Muscle group name\r\n * @param {boolean} hasIllness - Whether trainee has illness/injury\r\n * @returns {Object} - Recovery session recommendation\r\n */\r\nfunction calculateRecoveryVolume(muscle, hasIllness = false) {\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  const recoveryVolume = trainingState.getRecoveryVolume(muscle, hasIllness);\r\n  \r\n  return {\r\n    muscle,\r\n    recommendedSets: recoveryVolume,\r\n    reasoning: hasIllness ? 'illness adjustment' : 'standard recovery',\r\n    landmarks,\r\n    percentage: Math.round((recoveryVolume / landmarks.MEV) * 100)\r\n  };\r\n}\r\n\r\n/**\r\n * Validate volume input against landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} proposedSets - Proposed weekly sets\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateVolumeInput(muscle, proposedSets) {\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  const isValid = proposedSets >= 0 && proposedSets <= landmarks.MRV * 1.2; // Allow 20% over MRV\r\n  \r\n  let warning = '';\r\n  if (proposedSets < 0) {\r\n    warning = 'Sets cannot be negative';\r\n  } else if (proposedSets > landmarks.MRV) {\r\n    warning = `Above MRV (${landmarks.MRV}). Consider deload.`;\r\n  } else if (proposedSets < landmarks.MV) {\r\n    warning = `Below MV (${landmarks.MV}). May not be sufficient for adaptation.`;\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    warning,\r\n    proposedSets,\r\n    landmarks\r\n  };\r\n}\r\n\r\n/**\r\n * Get volume progression recommendation for next week\r\n * @param {string} muscle - Muscle group name\r\n * @param {Object} feedback - Latest training feedback\r\n * @returns {Object} - Next week recommendation\r\n */\r\nfunction getVolumeProgression(muscle, feedback) {\r\n  const currentSets = trainingState.currentWeekSets[muscle];\r\n  const volumeAnalysis = analyzeVolumeStatus(muscle);\r\n  \r\n  // Get stimulus score\r\n  const stimulusResult = scoreStimulus(feedback.stimulus);\r\n  \r\n  // Get set progression recommendation\r\n  const progressionResult = setProgressionAlgorithm(feedback.soreness, feedback.performance);\r\n  \r\n  // Combine recommendations with volume constraints\r\n  let finalSetChange = progressionResult.setChange;\r\n  let finalAdvice = progressionResult.advice;\r\n  \r\n  // Override if at volume limits\r\n  if (volumeAnalysis.status === 'maximum' && finalSetChange > 0) {\r\n    finalSetChange = 0;\r\n    finalAdvice = \"At MRV limit. Hold sets or consider deload.\";\r\n  }\r\n  \r\n  if (volumeAnalysis.status === 'under-minimum' && finalSetChange <= 0) {\r\n    finalSetChange = 2;\r\n    finalAdvice = \"Below minimum volume. Add sets regardless of fatigue.\";\r\n  }\r\n  \r\n  // Special handling for recovery sessions\r\n  if (progressionResult.action === 'recovery') {\r\n    const recoveryVolume = calculateRecoveryVolume(muscle, feedback.hasIllness);\r\n    finalSetChange = recoveryVolume.recommendedSets - currentSets;\r\n    finalAdvice = `Recovery session: ${recoveryVolume.recommendedSets} sets (${recoveryVolume.reasoning})`;\r\n  }\r\n  \r\n  const projectedSets = Math.max(0, currentSets + finalSetChange);\r\n  \r\n  return {\r\n    muscle,\r\n    currentSets,\r\n    projectedSets,\r\n    setChange: finalSetChange,\r\n    advice: finalAdvice,\r\n    stimulusScore: stimulusResult.score,\r\n    volumeStatus: volumeAnalysis.status,\r\n    targetRIR: trainingState.getTargetRIR(),\r\n    deloadRecommended: trainingState.shouldDeload()\r\n  };\r\n}\r\n\r\n/**\r\n * Analyze all muscles for deload necessity\r\n * @returns {Object} - Deload analysis\r\n */\r\nfunction analyzeDeloadNeed() {\r\n  const muscles = Object.keys(trainingState.volumeLandmarks);\r\n  const mrvBreaches = muscles.filter(muscle => \r\n    trainingState.getVolumeStatus(muscle) === 'maximum'\r\n  );\r\n  \r\n  const shouldDeload = trainingState.shouldDeload();\r\n  const reasons = [];\r\n  \r\n  if (trainingState.consecutiveMRVWeeks >= 2) {\r\n    reasons.push('Two consecutive weeks at MRV');\r\n  }\r\n  \r\n  if (trainingState.totalMusclesNeedingRecovery >= Math.ceil(muscles.length / 2)) {\r\n    reasons.push('Most muscles need recovery sessions');\r\n  }\r\n  \r\n  if (trainingState.weekNo >= trainingState.mesoLen) {\r\n    reasons.push('End of mesocycle reached');\r\n  }\r\n  \r\n  if (mrvBreaches.length >= Math.ceil(muscles.length / 3)) {\r\n    reasons.push(`${mrvBreaches.length} muscle groups at/above MRV`);\r\n  }\r\n  \r\n  return {\r\n    shouldDeload,\r\n    reasons,\r\n    mrvBreaches,\r\n    consecutiveMRVWeeks: trainingState.consecutiveMRVWeeks,\r\n    currentWeek: trainingState.weekNo,\r\n    mesoLength: trainingState.mesoLen,\r\n    musclesNeedingRecovery: trainingState.totalMusclesNeedingRecovery\r\n  };\r\n}\r\n\r\n// Export all functions\r\nexport {\r\n  scoreStimulus,\r\n  scoreStimulus as mevStimulusEstimator,\r\n  setProgressionAlgorithm,\r\n  setProgressionAlgorithm as rpSetProgression,\r\n  analyzeVolumeStatus,\r\n  calculateRecoveryVolume,\r\n  validateVolumeInput,\r\n  getVolumeProgression,\r\n  analyzeDeloadNeed\r\n};\r\n","/**\r\n * Renaissance Periodization Effort Management\r\n * Handles RIR (Reps In Reserve) calculations and effort progression\r\n */\r\n\r\nimport trainingState from '../core/trainingState.js';\r\n\r\n/**\r\n * Calculate target RIR based on meso progression\r\n * @param {number} weekNumber - Current week (1-based)\r\n * @param {number} mesoLength - Total weeks in mesocycle\r\n * @param {number} startRIR - Starting RIR (default 3)\r\n * @param {number} endRIR - Ending RIR (default 0.5)\r\n * @returns {Object} - RIR calculation result\r\n */\r\nfunction calculateTargetRIR(weekNumber = null, mesoLength = null, startRIR = 3, endRIR = 0.5) {\r\n  const week = weekNumber || trainingState.weekNo;\r\n  const mesoLen = mesoLength || trainingState.mesoLen;\r\n  \r\n  if (week > mesoLen) {\r\n    return {\r\n      targetRIR: startRIR,\r\n      warning: 'Week exceeds mesocycle length',\r\n      progression: 0\r\n    };\r\n  }\r\n  \r\n  // Linear progression from start to end RIR\r\n  const progressionRate = (startRIR - endRIR) / (mesoLen - 1);\r\n  const targetRIR = startRIR - (progressionRate * (week - 1));\r\n  const clampedRIR = Math.max(endRIR, Math.min(startRIR, targetRIR));\r\n  \r\n  // Calculate progression percentage\r\n  const progression = ((week - 1) / (mesoLen - 1)) * 100;\r\n    let intensityLevel = 'moderate';\r\n  let advice = '';\r\n  \r\n  if (clampedRIR >= 2.5) {\r\n    intensityLevel = 'low';\r\n    advice = 'Focus on form and mind-muscle connection';\r\n  } else if (clampedRIR >= 2.0) {\r\n    intensityLevel = 'moderate';\r\n    advice = 'Balanced effort - challenge without excessive fatigue';\r\n  } else if (clampedRIR >= 1.0) {\r\n    intensityLevel = 'high';\r\n    advice = 'High effort - monitor recovery closely';\r\n  } else {\r\n    intensityLevel = 'maximum';\r\n    advice = 'Maximum effort - deload approaching';\r\n  }\r\n  \r\n  return {\r\n    targetRIR: Math.round(clampedRIR * 2) / 2, // Round to nearest 0.5\r\n    intensityLevel,\r\n    advice,\r\n    progression: Math.round(progression),\r\n    week,\r\n    mesoLength: mesoLen\r\n  };\r\n}\r\n\r\n/**\r\n * Validate actual RIR against target\r\n * @param {number} actualRIR - Actual RIR reported\r\n * @param {number} targetRIR - Target RIR for the week\r\n * @param {number} tolerance - Acceptable deviation (default 1)\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateEffortLevel(actualRIR, targetRIR = null, tolerance = 1) {\r\n  const target = targetRIR || trainingState.getTargetRIR();\r\n  const deviation = Math.abs(actualRIR - target);\r\n  const isWithinTolerance = deviation <= tolerance;\r\n  \r\n  let feedback = '';\r\n  let recommendation = '';\r\n  let urgency = 'normal';\r\n  \r\n  if (isWithinTolerance) {\r\n    feedback = `On target (${actualRIR} vs ${target} RIR)`;\r\n    recommendation = 'Continue current effort level';\r\n    urgency = 'normal';\r\n  } else if (actualRIR > target) {\r\n    const difference = actualRIR - target;\r\n    feedback = `Too easy (${difference} RIR above target)`;\r\n    recommendation = difference > 2 ? 'Increase weight significantly' : 'Increase weight moderately';\r\n    urgency = difference > 2 ? 'high' : 'medium';\r\n  } else {\r\n    const difference = target - actualRIR;\r\n    feedback = `Too hard (${difference} RIR below target)`;\r\n    recommendation = difference > 2 ? 'Reduce weight significantly' : 'Reduce weight slightly';\r\n    urgency = difference > 2 ? 'high' : 'medium';\r\n  }\r\n  \r\n  return {\r\n    actualRIR,\r\n    targetRIR: target,\r\n    deviation,\r\n    isWithinTolerance,\r\n    feedback,\r\n    recommendation,\r\n    urgency\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate effort progression for next session\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} lastSession - Last session data\r\n * @returns {Object} - Effort progression recommendation\r\n */\r\nfunction getEffortProgression(muscle, lastSession) {\r\n  const currentRIR = trainingState.getTargetRIR();\r\n  const volumeStatus = trainingState.getVolumeStatus(muscle);\r\n  \r\n  let weightRecommendation = 'maintain';\r\n  let rirAdjustment = 0;\r\n  let advice = '';\r\n  \r\n  // Base progression on last session performance\r\n  if (lastSession.actualRIR < lastSession.targetRIR - 1.5) {\r\n    // Too hard last time\r\n    weightRecommendation = 'decrease';\r\n    rirAdjustment = 0.5;\r\n    advice = 'Reduce weight to hit target RIR';\r\n  } else if (lastSession.actualRIR > lastSession.targetRIR + 1.5) {\r\n    // Too easy last time\r\n    weightRecommendation = 'increase';\r\n    rirAdjustment = -0.5;\r\n    advice = 'Increase weight to hit target RIR';\r\n  } else {\r\n    // On target\r\n    if (volumeStatus === 'maximum') {\r\n      advice = 'Maintain weight - at volume limit';\r\n    } else {\r\n      advice = 'Good effort level - continue progression';\r\n    }\r\n  }\r\n  \r\n  // Adjust based on volume status\r\n  if (volumeStatus === 'maximum' && weightRecommendation === 'increase') {\r\n    weightRecommendation = 'maintain';\r\n    advice = 'At MRV - avoid adding intensity stress';\r\n  }\r\n  \r\n  const projectedRIR = Math.max(0, currentRIR + rirAdjustment);\r\n  \r\n  return {\r\n    muscle,\r\n    currentTargetRIR: currentRIR,\r\n    projectedRIR,\r\n    weightRecommendation,\r\n    advice,\r\n    volumeStatus\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate autoregulation recommendations\r\n * @param {Object} sessionFeedback - Real-time session feedback\r\n * @returns {Object} - Autoregulation advice\r\n */\r\nfunction getAutoregulationAdvice(sessionFeedback) {\r\n  const { actualRIR, plannedRIR, setNumber, totalPlannedSets, muscle } = sessionFeedback;\r\n  const deviation = actualRIR - plannedRIR;\r\n  \r\n  let advice = '';\r\n  let action = 'continue';\r\n  let weightAdjustment = 0; // Percentage\r\n  \r\n  // Early sets (first 1/3)\r\n  if (setNumber <= Math.ceil(totalPlannedSets / 3)) {\r\n    if (deviation > 1.5) {\r\n      advice = 'Weight too light - increase by 5-10%';\r\n      action = 'increase_weight';\r\n      weightAdjustment = 7.5;\r\n    } else if (deviation < -1.5) {\r\n      advice = 'Weight too heavy - decrease by 5-10%';\r\n      action = 'decrease_weight';\r\n      weightAdjustment = -7.5;\r\n    } else {\r\n      advice = 'Weight appropriate - continue';\r\n    }\r\n  }\r\n  // Middle sets (middle 1/3)\r\n  else if (setNumber <= Math.ceil(totalPlannedSets * 2 / 3)) {\r\n    if (deviation > 2) {\r\n      advice = 'Still too easy - increase weight';\r\n      action = 'increase_weight';\r\n      weightAdjustment = 5;\r\n    } else if (deviation < -2) {\r\n      advice = 'Too fatiguing - consider stopping early';\r\n      action = 'consider_stopping';\r\n      weightAdjustment = 0;\r\n    } else {\r\n      advice = 'Good progression - continue';\r\n    }\r\n  }\r\n  // Final sets (last 1/3)\r\n  else {\r\n    if (deviation < -1) {\r\n      advice = 'Very fatiguing - consider stopping to preserve recovery';\r\n      action = 'consider_stopping';\r\n    } else if (deviation > 2) {\r\n      advice = 'Could push harder - add 1-2 sets if recovering well';\r\n      action = 'consider_adding_sets';\r\n    } else {\r\n      advice = 'Appropriate fatigue for final sets';\r\n    }\r\n  }\r\n  \r\n  return {\r\n    setNumber,\r\n    totalPlannedSets,\r\n    actualRIR,\r\n    plannedRIR,\r\n    deviation,\r\n    advice,\r\n    action,\r\n    weightAdjustment\r\n  };\r\n}\r\n\r\n/**\r\n * Generate weekly effort summary\r\n * @returns {Object} - Weekly effort analysis\r\n */\r\nfunction getWeeklyEffortSummary() {\r\n  const currentWeek = trainingState.weekNo;\r\n  const mesoLength = trainingState.mesoLen;\r\n  const targetRIR = trainingState.getTargetRIR();\r\n  \r\n  const weeklyAdvice = [];\r\n  \r\n  // Week-specific advice\r\n  if (currentWeek === 1) {\r\n    weeklyAdvice.push('Focus on technique and mind-muscle connection');\r\n    weeklyAdvice.push('Establish baseline weights for the mesocycle');\r\n  } else if (currentWeek === mesoLength) {\r\n    weeklyAdvice.push('Peak intensity week - push close to failure');\r\n    weeklyAdvice.push('Prepare for upcoming deload');\r\n  } else if (currentWeek > mesoLength * 0.75) {\r\n    weeklyAdvice.push('High intensity phase - monitor recovery closely');\r\n    weeklyAdvice.push('Focus on performance over volume additions');\r\n  } else {\r\n    weeklyAdvice.push('Progressive overload phase - gradually increase demands');\r\n    weeklyAdvice.push('Balance volume and intensity progression');\r\n  }\r\n  \r\n  return {\r\n    currentWeek,\r\n    mesoLength,\r\n    targetRIR,\r\n    weeklyAdvice,\r\n    phaseDescription: getPhaseDescription(currentWeek, mesoLength)\r\n  };\r\n}\r\n\r\n/**\r\n * Get phase description based on week\r\n * @param {number} week - Current week\r\n * @param {number} mesoLength - Total meso length\r\n * @returns {string} - Phase description\r\n */\r\nfunction getPhaseDescription(week, mesoLength) {\r\n  const percentage = (week / mesoLength) * 100;\r\n  \r\n  if (percentage <= 25) {\r\n    return 'Accumulation Phase - Building foundation';\r\n  } else if (percentage <= 60) {\r\n    return 'Progression Phase - Steady overload';\r\n  } else if (percentage <= 85) {\r\n    return 'Intensification Phase - High demands';\r\n  } else {\r\n    return 'Peak Phase - Maximum effort';\r\n  }\r\n}\r\n\r\nexport {\r\n  calculateTargetRIR,\r\n  validateEffortLevel,\r\n  getEffortProgression,\r\n  getWeeklyEffortSummary,\r\n  getAutoregulationAdvice\r\n};\r\n","/**\r\n * Renaissance Periodization Fatigue Management\r\n * Handles recovery monitoring, frequency optimization, and fatigue accumulation\r\n */\r\n\r\nimport trainingState from '../core/trainingState.js';\r\n\r\n/**\r\n * Analyze recovery status and frequency optimization\r\n * @param {number} sorenessRecoveryDays - Days until soreness is gone\r\n * @param {number} currentSessionGap - Days between sessions for this muscle\r\n * @param {string} muscle - Muscle group name\r\n * @returns {Object} - Frequency analysis\r\n */\r\nfunction analyzeFrequency(sorenessRecoveryDays, currentSessionGap, muscle = null) {\r\n  const recoveryTime = Math.max(0, sorenessRecoveryDays);\r\n  const sessionGap = Math.max(1, currentSessionGap);\r\n  \r\n  let recommendation = '';\r\n  let action = '';\r\n  let urgency = 'normal';\r\n  let frequencyAdjustment = 0;\r\n  \r\n  // Recovery vs session gap analysis\r\n  const recoveryRatio = recoveryTime / sessionGap;\r\n  \r\n  if (recoveryRatio < 0.7) {\r\n    // Recovering much faster than session frequency\r\n    recommendation = 'You heal early  Add one session per week';\r\n    action = 'increase_frequency';\r\n    frequencyAdjustment = 1;\r\n    urgency = 'medium';\r\n  } else if (recoveryRatio > 1.3) {\r\n    // Still sore when next session is due\r\n    recommendation = 'Recovery lags  Insert an extra rest day';\r\n    action = 'decrease_frequency';\r\n    frequencyAdjustment = -1;\r\n    urgency = 'high';\r\n  } else {\r\n    // Optimal recovery timing\r\n    recommendation = 'Frequency is optimal';\r\n    action = 'maintain';\r\n    frequencyAdjustment = 0;\r\n    urgency = 'normal';\r\n  }\r\n  \r\n  // Consider current volume when making frequency recommendations\r\n  if (muscle) {\r\n    const volumeStatus = trainingState.getVolumeStatus(muscle);\r\n    \r\n    if (volumeStatus === 'maximum' && action === 'increase_frequency') {\r\n      recommendation = 'At MRV - maintain frequency despite early recovery';\r\n      action = 'maintain';\r\n      frequencyAdjustment = 0;\r\n    }\r\n    \r\n    if (volumeStatus === 'under-minimum' && action === 'decrease_frequency') {\r\n      recommendation = 'Below MV - consider recovery methods instead of reducing frequency';\r\n      action = 'improve_recovery';\r\n      frequencyAdjustment = 0;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    sorenessRecoveryDays: recoveryTime,\r\n    currentSessionGap: sessionGap,\r\n    recoveryRatio: Math.round(recoveryRatio * 100) / 100,\r\n    recommendation,\r\n    action,\r\n    frequencyAdjustment,\r\n    urgency,\r\n    muscle\r\n  };\r\n}\r\n\r\n/**\r\n * Assess overall fatigue accumulation\r\n * @param {Object} weeklyData - Weekly fatigue metrics\r\n * @returns {Object} - Fatigue assessment\r\n */\r\nfunction assessFatigueAccumulation(weeklyData) {\r\n  const {\r\n    averageSoreness = 1,\r\n    sleepQuality = 7, // 1-10 scale\r\n    stressLevel = 5, // 1-10 scale  \r\n    musclesNeedingRecovery = 0,\r\n    consecutiveMRVWeeks = 0,\r\n    performanceDecline = false\r\n  } = weeklyData;\r\n  \r\n  // Calculate fatigue score (0-100)\r\n  let fatigueScore = 0;\r\n  \r\n  // Soreness contribution (0-30 points)\r\n  fatigueScore += Math.min(30, (averageSoreness / 3) * 30);\r\n  \r\n  // Sleep quality contribution (0-20 points, inverted)\r\n  fatigueScore += Math.max(0, 20 - (sleepQuality / 10) * 20);\r\n  \r\n  // Stress level contribution (0-20 points)\r\n  fatigueScore += (stressLevel / 10) * 20;\r\n  \r\n  // Volume overreaching contribution (0-20 points)\r\n  const volumeOverreach = Math.min(20, (musclesNeedingRecovery / 12) * 20);\r\n  fatigueScore += volumeOverreach;\r\n  \r\n  // Consecutive MRV weeks (0-10 points)\r\n  fatigueScore += Math.min(10, consecutiveMRVWeeks * 5);\r\n  \r\n  // Performance decline bonus\r\n  if (performanceDecline) {\r\n    fatigueScore += 10;\r\n  }\r\n  \r\n  // Determine fatigue level\r\n  let fatigueLevel = '';\r\n  let recommendations = [];\r\n  let deloadUrgency = 'none';\r\n  \r\n  if (fatigueScore <= 25) {\r\n    fatigueLevel = 'low';\r\n    recommendations.push('Continue current program');\r\n    recommendations.push('Consider volume progression opportunities');\r\n  } else if (fatigueScore <= 50) {\r\n    fatigueLevel = 'moderate';\r\n    recommendations.push('Monitor recovery closely');\r\n    recommendations.push('Ensure adequate sleep and nutrition');\r\n    deloadUrgency = 'low';\r\n  } else if (fatigueScore <= 75) {\r\n    fatigueLevel = 'high';\r\n    recommendations.push('Reduce training stress');\r\n    recommendations.push('Consider recovery week');\r\n    recommendations.push('Prioritize sleep and stress management');\r\n    deloadUrgency = 'medium';\r\n  } else {\r\n    fatigueLevel = 'excessive';\r\n    recommendations.push('Implement deload immediately');\r\n    recommendations.push('Address sleep and lifestyle factors');\r\n    recommendations.push('Consider extending deload period');\r\n    deloadUrgency = 'high';\r\n  }\r\n  \r\n  return {\r\n    fatigueScore: Math.round(fatigueScore),\r\n    fatigueLevel,\r\n    recommendations,\r\n    deloadUrgency,\r\n    breakdown: {\r\n      soreness: Math.min(30, (averageSoreness / 3) * 30),\r\n      sleep: Math.max(0, 20 - (sleepQuality / 10) * 20),\r\n      stress: (stressLevel / 10) * 20,\r\n      volume: volumeOverreach,\r\n      consecutive: Math.min(10, consecutiveMRVWeeks * 5),\r\n      performance: performanceDecline ? 10 : 0\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Generate recovery session recommendations\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} options - Recovery options\r\n * @returns {Object} - Recovery session plan\r\n */\r\nfunction generateRecoverySession(muscle, options = {}) {\r\n  const {\r\n    hasIllness = false,\r\n    sorenessLevel = 2,\r\n    lastSessionRIR = 0,\r\n    preferredRecoveryType = 'volume'\r\n  } = options;\r\n  \r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  const baseRecoveryVolume = trainingState.getRecoveryVolume(muscle, hasIllness);\r\n  \r\n  let recoveryPlan = {\r\n    muscle,\r\n    type: preferredRecoveryType,\r\n    sets: baseRecoveryVolume,\r\n    intensity: '60-70% of normal',\r\n    rirTarget: '3-4 RIR',\r\n    duration: '1 session',\r\n    notes: []\r\n  };\r\n  \r\n  // Adjust based on soreness level\r\n  if (sorenessLevel >= 3) {\r\n    recoveryPlan.sets = Math.round(baseRecoveryVolume * 0.7);\r\n    recoveryPlan.intensity = '50-60% of normal';\r\n    recoveryPlan.rirTarget = '4-5 RIR';\r\n    recoveryPlan.notes.push('High soreness - very light session');\r\n  }\r\n  \r\n  // Adjust for illness\r\n  if (hasIllness) {\r\n    recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\r\n    recoveryPlan.intensity = '40-50% of normal';\r\n    recoveryPlan.notes.push('Illness present - prioritize rest');\r\n  }\r\n  \r\n  // Adjust based on last session intensity\r\n  if (lastSessionRIR <= 0.5) {\r\n    recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\r\n    recoveryPlan.notes.push('Last session was very intense');\r\n  }\r\n  \r\n  // Recovery type specific adjustments\r\n  if (preferredRecoveryType === 'deload') {\r\n    recoveryPlan.sets = Math.round(landmarks.MEV * 0.5);\r\n    recoveryPlan.intensity = '40-50% of normal';\r\n    recoveryPlan.duration = '3-7 days';\r\n    recoveryPlan.notes.push('Full deload protocol');\r\n  }\r\n  \r\n  return recoveryPlan;\r\n}\r\n\r\n/**\r\n * Monitor overreaching vs overtraining risk\r\n * @param {Object} metrics - Training metrics over time\r\n * @returns {Object} - Risk assessment\r\n */\r\nfunction assessOverreachingRisk(metrics) {\r\n  const {\r\n    weeklyPerformanceTrend = [], // Array of performance scores\r\n    weeklyFatigueTrend = [], // Array of fatigue scores\r\n    volumeProgression = [], // Array of weekly volumes\r\n    motivationLevel = 5, // 1-10\r\n    injuryRisk = 1 // 1-10\r\n  } = metrics;\r\n  \r\n  let riskScore = 0;\r\n  let riskFactors = [];\r\n  \r\n  // Performance trend analysis\r\n  if (weeklyPerformanceTrend.length >= 2) {\r\n    const recentTrend = weeklyPerformanceTrend.slice(-3);\r\n    const isDecreasing = recentTrend.every((val, i) => \r\n      i === 0 || val <= recentTrend[i - 1]\r\n    );\r\n    \r\n    if (isDecreasing) {\r\n      riskScore += 20;\r\n      riskFactors.push('Consistent performance decline');\r\n    }\r\n  }\r\n  \r\n  // Fatigue accumulation\r\n  if (weeklyFatigueTrend.length >= 2) {\r\n    const avgFatigue = weeklyFatigueTrend.reduce((a, b) => a + b, 0) / weeklyFatigueTrend.length;\r\n    if (avgFatigue > 60) {\r\n      riskScore += 25;\r\n      riskFactors.push('High average fatigue');\r\n    }\r\n  }\r\n  \r\n  // Volume progression rate\r\n  if (volumeProgression.length >= 3) {\r\n    const volumeIncrease = volumeProgression[volumeProgression.length - 1] - volumeProgression[0];\r\n    const weekSpan = volumeProgression.length;\r\n    const weeklyIncrease = volumeIncrease / weekSpan;\r\n    \r\n    if (weeklyIncrease > 2) {\r\n      riskScore += 15;\r\n      riskFactors.push('Rapid volume progression');\r\n    }\r\n  }\r\n  \r\n  // Motivation and wellbeing\r\n  if (motivationLevel <= 3) {\r\n    riskScore += 15;\r\n    riskFactors.push('Low motivation/enjoyment');\r\n  }\r\n  \r\n  // Injury risk\r\n  if (injuryRisk >= 7) {\r\n    riskScore += 15;\r\n    riskFactors.push('High injury risk indicators');\r\n  }\r\n  \r\n  // Current training state\r\n  if (trainingState.consecutiveMRVWeeks >= 2) {\r\n    riskScore += 10;\r\n    riskFactors.push('Consecutive weeks at MRV');\r\n  }\r\n  \r\n  // Determine risk level\r\n  let riskLevel = '';\r\n  let recommendations = [];\r\n  \r\n  if (riskScore <= 20) {\r\n    riskLevel = 'low';\r\n    recommendations.push('Continue progressive overload');\r\n    recommendations.push('Monitor for early warning signs');\r\n  } else if (riskScore <= 40) {\r\n    riskLevel = 'moderate';\r\n    recommendations.push('Slow progression rate');\r\n    recommendations.push('Increase recovery focus');\r\n    recommendations.push('Consider planned deload');\r\n  } else if (riskScore <= 70) {\r\n    riskLevel = 'high';\r\n    recommendations.push('Implement deload week');\r\n    recommendations.push('Address lifestyle stressors');\r\n    recommendations.push('Reduce training frequency');\r\n  } else {\r\n    riskLevel = 'critical';\r\n    recommendations.push('Stop training temporarily');\r\n    recommendations.push('Focus on full recovery');\r\n    recommendations.push('Consult with coach/healthcare provider');\r\n  }\r\n  \r\n  return {\r\n    riskScore,\r\n    riskLevel,\r\n    riskFactors,\r\n    recommendations,\r\n    requiresImmediateAction: riskScore > 60\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate optimal session frequency for a muscle\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} constraints - Training constraints\r\n * @returns {Object} - Frequency recommendation\r\n */\r\nfunction calculateOptimalFrequency(muscle, constraints = {}) {\r\n  const {\r\n    availableDays = 6,\r\n    currentVolume = null,\r\n    recoveryCapacity = 'normal', // low, normal, high\r\n    trainingAge = 'intermediate' // beginner, intermediate, advanced\r\n  } = constraints;\r\n  \r\n  const volume = currentVolume || trainingState.currentWeekSets[muscle];\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  \r\n  // Base frequency recommendations by training age\r\n  const baseFrequencies = {\r\n    beginner: { min: 2, max: 3 },\r\n    intermediate: { min: 2, max: 4 },\r\n    advanced: { min: 3, max: 5 }\r\n  };\r\n  \r\n  const ageRecommendation = baseFrequencies[trainingAge];\r\n  \r\n  // Adjust for volume\r\n  let volumeFrequency = 2;\r\n  if (volume >= landmarks.MAV) {\r\n    volumeFrequency = Math.min(4, Math.ceil(volume / 6)); // ~6 sets per session max at high volumes\r\n  } else if (volume >= landmarks.MEV) {\r\n    volumeFrequency = Math.min(3, Math.ceil(volume / 8)); // ~8 sets per session\r\n  } else {\r\n    volumeFrequency = Math.max(2, Math.ceil(volume / 10)); // ~10 sets per session at lower volumes\r\n  }\r\n  \r\n  // Adjust for recovery capacity\r\n  const recoveryMultipliers = {\r\n    low: 0.8,\r\n    normal: 1.0,\r\n    high: 1.2\r\n  };\r\n  \r\n  const adjustedFrequency = Math.round(volumeFrequency * recoveryMultipliers[recoveryCapacity]);\r\n  \r\n  // Constrain to available days and training age limits\r\n  const recommendedFrequency = Math.max(\r\n    ageRecommendation.min,\r\n    Math.min(ageRecommendation.max, adjustedFrequency, availableDays)\r\n  );\r\n  \r\n  // Calculate sets per session\r\n  const setsPerSession = Math.ceil(volume / recommendedFrequency);\r\n  \r\n  return {\r\n    muscle,\r\n    recommendedFrequency,\r\n    setsPerSession,\r\n    totalVolume: volume,\r\n    reasoning: [\r\n      `${volume} weekly sets`,\r\n      `${recoveryCapacity} recovery capacity`,\r\n      `${trainingAge} training age`,\r\n      `${availableDays} available days`\r\n    ],\r\n    alternatives: {\r\n      conservative: Math.max(2, recommendedFrequency - 1),\r\n      aggressive: Math.min(availableDays, recommendedFrequency + 1)\r\n    }\r\n  };\r\n}\r\n\r\nexport {\r\n  analyzeFrequency,\r\n  calculateOptimalFrequency\r\n};\r\n","/**\r\n * Training Validation Helpers\r\n * Provides validation for loads, sets, and training parameters\r\n */\r\n\r\n/**\r\n * Validate load percentage (1RM)\r\n * @param {number} loadPercent - Load as percentage of 1RM\r\n * @param {string} context - Training context (hypertrophy, strength, power)\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateLoad(loadPercent, context = 'hypertrophy') {\r\n  const load = parseFloat(loadPercent);\r\n  \r\n  if (isNaN(load) || load <= 0) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'Load must be a positive number',\r\n      recommendation: 'Enter a valid load percentage'\r\n    };\r\n  }\r\n  \r\n  // Context-specific load ranges\r\n  const loadRanges = {\r\n    hypertrophy: { min: 30, max: 85, optimal: [65, 80] },\r\n    strength: { min: 70, max: 100, optimal: [85, 95] },\r\n    power: { min: 30, max: 70, optimal: [40, 60] },\r\n    endurance: { min: 20, max: 60, optimal: [30, 50] }\r\n  };\r\n  \r\n  const range = loadRanges[context] || loadRanges.hypertrophy;\r\n  \r\n  let isValid = true;\r\n  let warning = '';\r\n  let recommendation = '';\r\n  let severity = 'normal';\r\n  \r\n  if (load < range.min) {\r\n    isValid = false;\r\n    warning = `Load too light for ${context} (${load}% < ${range.min}%)`;\r\n    recommendation = `Increase to ${range.optimal[0]}-${range.optimal[1]}% for optimal ${context} adaptations`;\r\n    severity = 'high';\r\n  } else if (load > range.max) {\r\n    isValid = false;\r\n    warning = `Load too heavy for ${context} (${load}% > ${range.max}%)`;\r\n    recommendation = `Reduce to ${range.optimal[0]}-${range.optimal[1]}% for safer ${context} training`;\r\n    severity = 'high';\r\n  } else if (load < range.optimal[0]) {\r\n    warning = `Load is light for ${context} (${load}% < ${range.optimal[0]}%)`;\r\n    recommendation = `Consider increasing to ${range.optimal[0]}-${range.optimal[1]}% for better stimulus`;\r\n    severity = 'medium';\r\n  } else if (load > range.optimal[1]) {\r\n    warning = `Load is heavy for ${context} (${load}% > ${range.optimal[1]}%)`;\r\n    recommendation = `Consider reducing to ${range.optimal[0]}-${range.optimal[1]}% for better recovery`;\r\n    severity = 'medium';\r\n  } else {\r\n    recommendation = `Good load for ${context} training`;\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    load,\r\n    context,\r\n    warning,\r\n    recommendation,\r\n    severity,\r\n    range,\r\n    isOptimal: load >= range.optimal[0] && load <= range.optimal[1]\r\n  };\r\n}\r\n\r\n/**\r\n * Validate RIR (Reps in Reserve)\r\n * @param {number} rir - Reps in reserve\r\n * @param {number} targetRIR - Target RIR for the session\r\n * @param {string} context - Training context\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateRIR(rir, targetRIR, context = 'hypertrophy') {\r\n  const actualRIR = parseFloat(rir);\r\n  const target = parseFloat(targetRIR);\r\n  \r\n  if (isNaN(actualRIR) || actualRIR < 0) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'RIR must be 0 or greater',\r\n      recommendation: 'Enter how many more reps you could have done'\r\n    };\r\n  }\r\n  \r\n  if (actualRIR > 10) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'RIR too high (>10) - load likely too light',\r\n      recommendation: 'Increase weight significantly'\r\n    };\r\n  }\r\n  \r\n  const deviation = Math.abs(actualRIR - target);\r\n  let isValid = true;\r\n  let warning = '';\r\n  let recommendation = '';\r\n  let severity = 'normal';\r\n  \r\n  // Tolerance varies by context\r\n  const tolerances = {\r\n    hypertrophy: 1.0,\r\n    strength: 0.5,\r\n    power: 1.5,\r\n    endurance: 2.0\r\n  };\r\n  \r\n  const tolerance = tolerances[context] || tolerances.hypertrophy;\r\n  \r\n  if (deviation <= tolerance) {\r\n    recommendation = `On target (${actualRIR} vs ${target} RIR)`;\r\n  } else if (actualRIR > target) {\r\n    const difference = actualRIR - target;\r\n    warning = `Too easy (${difference.toFixed(1)} RIR above target)`;\r\n    \r\n    if (difference > 2) {\r\n      recommendation = 'Increase weight significantly (10-15%)';\r\n      severity = 'high';\r\n    } else {\r\n      recommendation = 'Increase weight moderately (5-10%)';\r\n      severity = 'medium';\r\n    }\r\n  } else {\r\n    const difference = target - actualRIR;\r\n    warning = `Too hard (${difference.toFixed(1)} RIR below target)`;\r\n    \r\n    if (difference > 2) {\r\n      recommendation = 'Reduce weight significantly (10-15%)';\r\n      severity = 'high';\r\n    } else {\r\n      recommendation = 'Reduce weight slightly (5-10%)';\r\n      severity = 'medium';\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    actualRIR,\r\n    targetRIR: target,\r\n    deviation,\r\n    warning,\r\n    recommendation,\r\n    severity,\r\n    isOnTarget: deviation <= tolerance\r\n  };\r\n}\r\n\r\n/**\r\n * Validate set count within volume landmarks\r\n * @param {number} sets - Proposed set count\r\n * @param {Object} landmarks - Volume landmarks {MV, MEV, MAV, MRV}\r\n * @param {boolean} allowOverreach - Allow sets above MRV\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateSets(sets, landmarks, allowOverreach = false) {\r\n  const setCount = parseInt(sets, 10);\r\n  \r\n  if (isNaN(setCount) || setCount < 0) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'Set count must be 0 or greater',\r\n      recommendation: 'Enter a valid number of sets'\r\n    };\r\n  }\r\n  \r\n  const { MV = 0, MEV, MAV, MRV } = landmarks;\r\n  \r\n  let isValid = true;\r\n  let warning = '';\r\n  let recommendation = '';\r\n  let severity = 'normal';\r\n  let zone = '';\r\n  \r\n  if (setCount < MV) {\r\n    zone = 'below-maintenance';\r\n    warning = `Below maintenance volume (${setCount} < ${MV})`;\r\n    recommendation = 'Increase sets for minimal stimulus';\r\n    severity = 'high';\r\n  } else if (setCount < MEV) {\r\n    zone = 'maintenance';\r\n    warning = `In maintenance zone (${setCount} < ${MEV})`;\r\n    recommendation = 'Increase sets for growth stimulus';\r\n    severity = 'medium';\r\n  } else if (setCount <= MAV) {\r\n    zone = 'optimal';\r\n    recommendation = `Optimal volume zone (${MEV}-${MAV} sets)`;\r\n  } else if (setCount <= MRV) {\r\n    zone = 'high';\r\n    warning = `High volume zone (${setCount} approaching ${MRV})`;\r\n    recommendation = 'Monitor recovery closely';\r\n    severity = 'medium';\r\n  } else {\r\n    zone = 'maximum';\r\n    \r\n    if (!allowOverreach) {\r\n      isValid = false;\r\n      warning = `Above maximum recoverable volume (${setCount} > ${MRV})`;\r\n      recommendation = 'Reduce sets or plan deload';\r\n      severity = 'high';\r\n    } else {\r\n      warning = `Overreaching territory (${setCount} > ${MRV})`;\r\n      recommendation = 'Short-term only - deload soon';\r\n      severity = 'high';\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    sets: setCount,\r\n    landmarks,\r\n    zone,\r\n    warning,\r\n    recommendation,\r\n    severity,\r\n    percentage: Math.round((setCount / MRV) * 100)\r\n  };\r\n}\r\n\r\n/**\r\n * Validate training frequency\r\n * @param {number} frequency - Sessions per week\r\n * @param {number} weeklyVolume - Total weekly sets\r\n * @param {string} muscleGroup - Muscle group name\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateFrequency(frequency, weeklyVolume, muscleGroup = '') {\r\n  const freq = parseInt(frequency, 10);\r\n  const volume = parseInt(weeklyVolume, 10);\r\n  \r\n  if (isNaN(freq) || freq < 1) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'Frequency must be at least 1 session per week',\r\n      recommendation: 'Train each muscle at least once per week'\r\n    };\r\n  }\r\n  \r\n  if (isNaN(volume) || volume < 0) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'Weekly volume must be specified',\r\n      recommendation: 'Enter total weekly sets'\r\n    };\r\n  }\r\n  \r\n  const setsPerSession = volume / freq;\r\n  let isValid = true;\r\n  let warning = '';\r\n  let recommendation = '';\r\n  let severity = 'normal';\r\n  \r\n  // General guidelines for sets per session\r\n  if (setsPerSession > 20) {\r\n    isValid = false;\r\n    warning = `Too many sets per session (${setsPerSession.toFixed(1)})`;\r\n    recommendation = 'Increase frequency or reduce volume';\r\n    severity = 'high';\r\n  } else if (setsPerSession > 12) {\r\n    warning = `High sets per session (${setsPerSession.toFixed(1)})`;\r\n    recommendation = 'Consider increasing frequency';\r\n    severity = 'medium';\r\n  } else if (setsPerSession < 2 && volume >= 6) {\r\n    warning = `Very low sets per session (${setsPerSession.toFixed(1)})`;\r\n    recommendation = 'Consider reducing frequency';\r\n    severity = 'medium';\r\n  } else {\r\n    recommendation = `Good distribution (${setsPerSession.toFixed(1)} sets/session)`;\r\n  }\r\n  \r\n  // Frequency-specific advice\r\n  let frequencyAdvice = '';\r\n  if (freq === 1) {\r\n    frequencyAdvice = 'Once weekly - ensure high quality';\r\n  } else if (freq === 2) {\r\n    frequencyAdvice = 'Twice weekly - good for most goals';\r\n  } else if (freq === 3) {\r\n    frequencyAdvice = 'Three times weekly - high frequency';\r\n  } else if (freq >= 4) {\r\n    frequencyAdvice = 'Very high frequency - monitor recovery';\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    frequency: freq,\r\n    weeklyVolume: volume,\r\n    setsPerSession: Math.round(setsPerSession * 10) / 10,\r\n    warning,\r\n    recommendation,\r\n    frequencyAdvice,\r\n    severity,\r\n    muscleGroup\r\n  };\r\n}\r\n\r\n/**\r\n * Validate mesocycle length\r\n * @param {number} weeks - Mesocycle length in weeks\r\n * @param {string} goal - Training goal\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateMesocycleLength(weeks, goal = 'hypertrophy') {\r\n  const mesoLength = parseInt(weeks, 10);\r\n  \r\n  if (isNaN(mesoLength) || mesoLength < 1) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'Mesocycle must be at least 1 week',\r\n      recommendation: 'Enter a valid mesocycle length'\r\n    };\r\n  }\r\n  \r\n  // Goal-specific recommendations\r\n  const recommendations = {\r\n    hypertrophy: { min: 3, max: 6, optimal: 4 },\r\n    strength: { min: 2, max: 8, optimal: 4 },\r\n    power: { min: 2, max: 4, optimal: 3 },\r\n    endurance: { min: 4, max: 12, optimal: 6 }\r\n  };\r\n  \r\n  const rec = recommendations[goal] || recommendations.hypertrophy;\r\n  \r\n  let isValid = true;\r\n  let warning = '';\r\n  let recommendation = '';\r\n  let severity = 'normal';\r\n  \r\n  if (mesoLength < rec.min) {\r\n    warning = `Short mesocycle for ${goal} (${mesoLength} < ${rec.min} weeks)`;\r\n    recommendation = `Consider ${rec.optimal} weeks for better ${goal} adaptations`;\r\n    severity = 'medium';\r\n  } else if (mesoLength > rec.max) {\r\n    warning = `Long mesocycle for ${goal} (${mesoLength} > ${rec.max} weeks)`;\r\n    recommendation = `Consider ${rec.optimal} weeks to prevent overreaching`;\r\n    severity = 'medium';\r\n  } else if (mesoLength === rec.optimal) {\r\n    recommendation = `Optimal length for ${goal} training`;\r\n  } else {\r\n    recommendation = `Good length for ${goal} training`;\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    weeks: mesoLength,\r\n    goal,\r\n    warning,\r\n    recommendation,\r\n    severity,\r\n    isOptimal: mesoLength === rec.optimal,\r\n    range: rec\r\n  };\r\n}\r\n\r\n/**\r\n * Validate input ranges for UI components\r\n * @param {*} value - Input value\r\n * @param {Object} constraints - Validation constraints\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateInputRange(value, constraints) {\r\n  const {\r\n    type = 'number',\r\n    min = null,\r\n    max = null,\r\n    step = null,\r\n    required = false,\r\n    customValidator = null\r\n  } = constraints;\r\n  \r\n  // Check if required\r\n  if (required && (value === null || value === undefined || value === '')) {\r\n    return {\r\n      isValid: false,\r\n      warning: 'This field is required',\r\n      recommendation: 'Please enter a value'\r\n    };\r\n  }\r\n  \r\n  // Type validation\r\n  if (type === 'number') {\r\n    const num = parseFloat(value);\r\n    \r\n    if (isNaN(num)) {\r\n      return {\r\n        isValid: false,\r\n        warning: 'Must be a valid number',\r\n        recommendation: 'Enter a numeric value'\r\n      };\r\n    }\r\n    \r\n    if (min !== null && num < min) {\r\n      return {\r\n        isValid: false,\r\n        warning: `Must be at least ${min}`,\r\n        recommendation: `Enter a value  ${min}`\r\n      };\r\n    }\r\n    \r\n    if (max !== null && num > max) {\r\n      return {\r\n        isValid: false,\r\n        warning: `Must be at most ${max}`,\r\n        recommendation: `Enter a value  ${max}`\r\n      };\r\n    }\r\n    \r\n    if (step !== null && ((num * 100) % (step * 100)) !== 0) {\r\n      return {\r\n        isValid: false,\r\n        warning: `Must be in increments of ${step}`,\r\n        recommendation: `Use multiples of ${step}`\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Custom validation\r\n  if (customValidator && typeof customValidator === 'function') {\r\n    const customResult = customValidator(value);\r\n    if (!customResult.isValid) {\r\n      return customResult;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: true,\r\n    value,\r\n    recommendation: 'Valid input'\r\n  };\r\n}\r\n\r\n/**\r\n * Create comprehensive validation summary\r\n * @param {Object} formData - Complete form data\r\n * @param {Object} validationRules - Validation rules for each field\r\n * @returns {Object} - Comprehensive validation result\r\n */\r\nfunction validateTrainingSession(formData, validationRules = {}) {\r\n  const results = {};\r\n  const errors = [];\r\n  const warnings = [];\r\n  \r\n  Object.keys(formData).forEach(field => {\r\n    const value = formData[field];\r\n    const rules = validationRules[field];\r\n    \r\n    if (rules) {\r\n      let result;\r\n      \r\n      switch (rules.type) {\r\n        case 'load':\r\n          result = validateLoad(value, rules.context);\r\n          break;\r\n        case 'rir':\r\n          result = validateRIR(value, rules.target, rules.context);\r\n          break;\r\n        case 'sets':\r\n          result = validateSets(value, rules.landmarks, rules.allowOverreach);\r\n          break;\r\n        case 'frequency':\r\n          result = validateFrequency(value, rules.volume, rules.muscle);\r\n          break;\r\n        case 'meso':\r\n          result = validateMesocycleLength(value, rules.goal);\r\n          break;\r\n        default:\r\n          result = validateInputRange(value, rules);\r\n      }\r\n      \r\n      results[field] = result;\r\n      \r\n      if (!result.isValid) {\r\n        errors.push(`${field}: ${result.warning}`);\r\n      } else if (result.warning) {\r\n        warnings.push(`${field}: ${result.warning}`);\r\n      }\r\n    }\r\n  });\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    hasWarnings: warnings.length > 0,\r\n    errors,\r\n    warnings,\r\n    fieldResults: results,\r\n    summary: errors.length === 0 ? \r\n      (warnings.length === 0 ? 'All inputs valid' : 'Valid with warnings') :\r\n      `${errors.length} validation error(s)`\r\n  };\r\n}\r\n\r\nexport {\r\n  validateLoad,\r\n  validateSets,\r\n  validateMesocycleLength\r\n};\r\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$a4aafd93596a3fc7$export$88eaec01eecac0a4","$a4aafd93596a3fc7$export$f07c621b7d36d1ec","$a4aafd93596a3fc7$export$1be07204ac5fe8ce","$a4aafd93596a3fc7$export$d2cfe3709d2fae1f","$a4aafd93596a3fc7$export$f09d42cecf7f68cf","$gBc5V","$a4aafd93596a3fc7$export$c9f6e7e078edfb63","$a4aafd93596a3fc7$var$muscles","keys","default","volumeLandmarks","canvas","document","getElementById","console","error","ctx","getContext","Chart","chartData","map","muscle","currentWeekSets","backgroundColors","getVolumeColor","type","data","labels","datasets","label","backgroundColor","borderColor","color","replace","borderWidth","MEV","pointRadius","pointBackgroundColor","borderDash","MRV","options","responsive","maintainAspectRatio","plugins","legend","tooltip","callbacks","afterLabel","context","sets","parsed","y","landmarks","status","getVolumeStatus","getTargetRIR","scales","beginAtZero","grid","ticks","stepSize","x","newData","newColors","update","forEach","updateWeeklySets","log","warn","base64Image","toBase64Image","link","createElement","download","weekNo","href","body","appendChild","click","removeChild","notification","style","cssText","textContent","setTimeout","$c1597bc275c4ccd9$export$2e2bcd8739ae039","$c1597bc275c4ccd9$var$TrainingState","instance","MV","MAV","mesoLen","blockNo","deloadPhase","resensitizationPhase","lastWeekSets","consecutiveMRVWeeks","recoverySessionsThisWeek","totalMusclesNeedingRecovery","loadState","Math","max","min","startRIR","progressionRate","currentSets","colors","saveState","addSets","additionalSets","shouldDeload","totalMuscles","length","ceil","shouldResensitize","startDeload","deloadSets","round","startResensitization","nextWeek","mrvBreaches","filter","resetWeek","updateVolumeLandmarks","getRecoveryVolume","hasIllness","midpoint","state","localStorage","setItem","JSON","stringify","saved","getItem","parse","assign","migrateLegacyData","muscles","hasLegacyData","oldKey","oldValue","parseInt","removeItem","mevKey","mrvKey","mevValue","mrvValue","getStateSummary","week","meso","block","targetRIR","deloadRecommended","resensitizationRecommended","currentPhase","$c1597bc275c4ccd9$var$trainingState","window","trainingState","$e164431b984951c9$export$18b9fbb49c39d8df","$e164431b984951c9$export$29edd766f0a47f8a","$e164431b984951c9$export$b31b69977bb86b2d","$e164431b984951c9$export$8d707a3cbe195ceb","$e164431b984951c9$export$8a692c73ed76fb03","$e164431b984951c9$export$4cb49ae975c76e14","mmc","pump","disruption","advice","action","setChange","clamp","val","clampedMmc","clampedPump","clampedDisruption","totalScore","score","breakdown","soreness","performance","p","progressionMatrix","percentage","recommendation","urgency","proposedSets","isValid","warning","feedback","volumeAnalysis","stimulusResult","stimulus","progressionResult","finalSetChange","finalAdvice","recoveryVolume","$e164431b984951c9$export$5093fcc2dc47d960","recommendedSets","reasoning","projectedSets","stimulusScore","volumeStatus","reasons","push","currentWeek","mesoLength","musclesNeedingRecovery","$706feb1901751bf0$export$aa142ff646b13b0f","$706feb1901751bf0$export$8bb5b09bc31b1524","weekNumber","endRIR","progression","clampedRIR","intensityLevel","actualRIR","tolerance","target","deviation","abs","isWithinTolerance","difference","$52d23339b7415571$export$e9e5518db45551d4","$52d23339b7415571$export$8d40c4b24105606b","sorenessRecoveryDays","currentSessionGap","recoveryTime","sessionGap","frequencyAdjustment","recoveryRatio","constraints","availableDays","currentVolume","recoveryCapacity","trainingAge","volume","ageRecommendation","baseFrequencies","beginner","intermediate","advanced","volumeFrequency","adjustedFrequency","recoveryMultipliers","low","normal","high","recommendedFrequency","setsPerSession","totalVolume","alternatives","conservative","aggressive","$80c479ce1d56b1ed$export$11d934779f97d76b","loadPercent","load","parseFloat","isNaN","loadRanges","hypertrophy","optimal","strength","power","endurance","range","severity","isOptimal","$80c479ce1d56b1ed$export$6a40f0625f84253c","allowOverreach","setCount","zone","$80c479ce1d56b1ed$export$22b78d0144c3de8d","weeks","goal","recommendations","rec"],"version":3,"file":"ProgramDesignWorkspace.a153faa7.js.map"}