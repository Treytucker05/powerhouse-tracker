{"mappings":"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","sources":["<anon>","sw.js"],"sourcesContent":["/**\r\n * PowerHouseATX Service Worker\r\n * Provides offline functionality and caching for the training application\r\n */ const CACHE_NAME = 'powerhouseatx-v2.0.0';\nconst STATIC_CACHE = 'powerhouseatx-static-v2.0.0';\nconst DYNAMIC_CACHE = 'powerhouseatx-dynamic-v2.0.0';\n// Files to cache for offline functionality\nconst STATIC_FILES = [\n    '/',\n    '/index.html',\n    '/test-next-generation.html',\n    '/test-advanced-intelligence.html',\n    '/css/enhancedAdvanced.css',\n    '/js/core/trainingState.js',\n    '/js/algorithms/volume.js',\n    '/js/algorithms/effort.js',\n    '/js/algorithms/fatigue.js',\n    '/js/algorithms/analytics.js',\n    '/js/algorithms/exerciseSelection.js',\n    '/js/algorithms/livePerformance.js',\n    '/js/algorithms/intelligenceHub.js',\n    '/js/algorithms/dataVisualization.js',\n    '/js/algorithms/wellnessIntegration.js',\n    '/js/algorithms/periodizationSystem.js',\n    '/js/ui/feedbackFormUI.js',\n    '/js/ui/globals.js',\n    '/js/ui/enhancedAdvancedUI.js',\n    '/js/utils/dataExport.js',\n    '/js/utils/userFeedback.js',\n    '/manifest.json',\n    'https://cdn.jsdelivr.net/npm/chart.js'\n];\n// Files that should always be fetched fresh\nconst NETWORK_FIRST = [\n    '/js/utils/userFeedback.js',\n    '/js/utils/dataExport.js'\n];\n// Install event - cache static files\nself.addEventListener('install', (event)=>{\n    console.log(\"\\uD83D\\uDD27 Service Worker installing...\");\n    event.waitUntil(Promise.all([\n        caches.open(STATIC_CACHE).then((cache)=>{\n            console.log(\"\\uD83D\\uDCE6 Caching static files...\");\n            return cache.addAll(STATIC_FILES.filter((url)=>!NETWORK_FIRST.includes(url)));\n        }),\n        caches.open(DYNAMIC_CACHE).then((cache)=>{\n            console.log(\"\\uD83D\\uDD04 Dynamic cache initialized\");\n            return cache;\n        })\n    ]).then(()=>{\n        console.log(\"\\u2705 Service Worker installation complete\");\n        return self.skipWaiting();\n    }));\n});\n// Activate event - cleanup old caches\nself.addEventListener('activate', (event)=>{\n    console.log(\"\\uD83D\\uDE80 Service Worker activating...\");\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.map((cacheName)=>{\n            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\n                console.log(\"\\uD83D\\uDDD1\\uFE0F Deleting old cache:\", cacheName);\n                return caches.delete(cacheName);\n            }\n        }));\n    }).then(()=>{\n        console.log(\"\\u2705 Service Worker activation complete\");\n        return self.clients.claim();\n    }));\n});\n// Fetch event - serve cached content or fetch from network\nself.addEventListener('fetch', (event)=>{\n    const { request } = event;\n    const url = new URL(request.url);\n    // Handle different types of requests\n    if (request.method === 'GET') {\n        if (isStaticFile(request.url)) event.respondWith(cacheFirst(request));\n        else if (isNetworkFirst(request.url)) event.respondWith(networkFirst(request));\n        else if (isAnalyticsRequest(request.url)) event.respondWith(handleAnalyticsRequest(request));\n        else event.respondWith(staleWhileRevalidate(request));\n    }\n});\n// Cache first strategy - for static files\nasync function cacheFirst(request) {\n    try {\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) return cachedResponse;\n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            const cache = await caches.open(STATIC_CACHE);\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    } catch (error) {\n        console.log(\"\\uD83D\\uDCE1 Network failed, serving from cache or fallback:\", error);\n        return await caches.match('/index.html') || new Response('Offline', {\n            status: 503\n        });\n    }\n}\n// Network first strategy - for dynamic content\nasync function networkFirst(request) {\n    try {\n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            const cache = await caches.open(DYNAMIC_CACHE);\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    } catch (error) {\n        console.log(\"\\uD83D\\uDCE1 Network failed, serving from cache:\", error);\n        const cachedResponse = await caches.match(request);\n        return cachedResponse || new Response('Offline', {\n            status: 503\n        });\n    }\n}\n// Stale while revalidate - for general content\nasync function staleWhileRevalidate(request) {\n    const cache = await caches.open(DYNAMIC_CACHE);\n    const cachedResponse = await cache.match(request);\n    const fetchPromise = fetch(request).then((networkResponse)=>{\n        if (networkResponse.ok) cache.put(request, networkResponse.clone());\n        return networkResponse;\n    }).catch((error)=>{\n        console.log(\"\\uD83D\\uDCE1 Network failed:\", error);\n        return cachedResponse;\n    });\n    return cachedResponse || await fetchPromise;\n}\n// Handle analytics requests (can work offline)\nasync function handleAnalyticsRequest(request) {\n    try {\n        return await fetch(request);\n    } catch (error) {\n        // Store analytics data locally when offline\n        const url = new URL(request.url);\n        const analyticsData = {\n            url: url.pathname,\n            timestamp: Date.now(),\n            offline: true\n        };\n        // Store in IndexedDB or return success response\n        return new Response(JSON.stringify({\n            success: true,\n            offline: true\n        }), {\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n    }\n}\n// Background sync for offline data\nself.addEventListener('sync', (event)=>{\n    console.log(\"\\uD83D\\uDD04 Background sync triggered:\", event.tag);\n    if (event.tag === 'background-sync-training-data') event.waitUntil(syncTrainingData());\n    else if (event.tag === 'background-sync-feedback') event.waitUntil(syncFeedbackData());\n});\n// Sync training data when back online\nasync function syncTrainingData() {\n    console.log(\"\\uD83D\\uDCCA Syncing training data...\");\n    try {\n        // Get pending training data from localStorage\n        const pendingSessions = getPendingSessionData();\n        const pendingFeedback = getPendingFeedbackData();\n        // Sync session data\n        for (const session of pendingSessions)await syncSession(session);\n        // Sync feedback data\n        for (const feedback of pendingFeedback)await syncFeedback(feedback);\n        console.log(\"\\u2705 Training data sync complete\");\n    } catch (error) {\n        console.error(\"\\u274C Training data sync failed:\", error);\n    }\n}\n// Sync feedback data when back online\nasync function syncFeedbackData() {\n    console.log(\"\\uD83D\\uDCAC Syncing feedback data...\");\n    try {\n        const pendingFeedback = getPendingUserFeedback();\n        for (const feedback of pendingFeedback)await syncUserFeedback(feedback);\n        console.log(\"\\u2705 Feedback sync complete\");\n    } catch (error) {\n        console.error(\"\\u274C Feedback sync failed:\", error);\n    }\n}\n// Push notifications for training reminders\nself.addEventListener('push', (event)=>{\n    console.log(\"\\uD83D\\uDCE2 Push notification received\");\n    const data = event.data ? event.data.json() : {};\n    const title = data.title || 'PowerHouseATX';\n    const options = {\n        body: data.body || 'Time for your training session!',\n        icon: '/icons/icon-192x192.png',\n        badge: '/icons/badge-72x72.png',\n        image: data.image,\n        data: data.data,\n        actions: [\n            {\n                action: 'start-session',\n                title: \"\\uD83C\\uDFCB\\uFE0F Start Session\",\n                icon: '/icons/action-start.png'\n            },\n            {\n                action: 'postpone',\n                title: \"\\u23F0 Postpone\",\n                icon: '/icons/action-postpone.png'\n            }\n        ],\n        requireInteraction: true,\n        vibrate: [\n            200,\n            100,\n            200\n        ]\n    };\n    event.waitUntil(self.registration.showNotification(title, options));\n});\n// Handle notification clicks\nself.addEventListener('notificationclick', (event)=>{\n    console.log(\"\\uD83D\\uDDB1\\uFE0F Notification clicked:\", event.action);\n    event.notification.close();\n    const action = event.action;\n    const data = event.notification.data || {};\n    if (action === 'start-session') event.waitUntil(clients.openWindow('/index.html#live-monitor'));\n    else if (action === 'postpone') // Schedule another reminder\n    scheduleTrainingReminder(30); // 30 minutes later\n    else // Default action - open app\n    event.waitUntil(clients.openWindow('/index.html'));\n});\n// Message handling for communication with main app\nself.addEventListener('message', (event)=>{\n    const { type, data } = event.data;\n    switch(type){\n        case 'SKIP_WAITING':\n            self.skipWaiting();\n            break;\n        case 'GET_CACHE_STATUS':\n            event.ports[0].postMessage({\n                cacheStatus: getCacheStatus()\n            });\n            break;\n        case 'CLEAR_CACHE':\n            clearAllCaches().then(()=>{\n                event.ports[0].postMessage({\n                    success: true\n                });\n            });\n            break;\n        case 'SCHEDULE_REMINDER':\n            scheduleTrainingReminder(data.minutes);\n            break;\n        case 'REGISTER_BACKGROUND_SYNC':\n            registerBackgroundSync(data.tag);\n            break;\n    }\n});\n// Utility functions\nfunction isStaticFile(url) {\n    return STATIC_FILES.some((file)=>url.includes(file)) || url.includes('.css') || url.includes('.js') || url.includes('.html');\n}\nfunction isNetworkFirst(url) {\n    return NETWORK_FIRST.some((file)=>url.includes(file));\n}\nfunction isAnalyticsRequest(url) {\n    return url.includes('analytics') || url.includes('feedback') || url.includes('tracking');\n}\nfunction getPendingSessionData() {\n    // This would integrate with the main app's localStorage\n    // For now, return empty array\n    return [];\n}\nfunction getPendingFeedbackData() {\n    // This would integrate with the main app's localStorage\n    return [];\n}\nfunction getPendingUserFeedback() {\n    // This would integrate with the feedback system\n    return [];\n}\nasync function syncSession(session) {\n    // Sync individual session to server\n    console.log(\"\\uD83D\\uDD04 Syncing session:\", session.id);\n}\nasync function syncFeedback(feedback) {\n    // Sync feedback to server\n    console.log(\"\\uD83D\\uDD04 Syncing feedback:\", feedback.id);\n}\nasync function syncUserFeedback(feedback) {\n    // Sync user feedback to server\n    console.log(\"\\uD83D\\uDD04 Syncing user feedback:\", feedback.id);\n}\nfunction getCacheStatus() {\n    return caches.keys().then((cacheNames)=>{\n        return {\n            caches: cacheNames,\n            version: CACHE_NAME\n        };\n    });\n}\nasync function clearAllCaches() {\n    const cacheNames = await caches.keys();\n    return Promise.all(cacheNames.map((cacheName)=>caches.delete(cacheName)));\n}\nfunction scheduleTrainingReminder(minutes) {\n    // Schedule a training reminder\n    console.log(`\\u{23F0} Training reminder scheduled for ${minutes} minutes`);\n}\nfunction registerBackgroundSync(tag) {\n    return self.registration.sync.register(tag);\n}\n// Performance monitoring\nself.addEventListener('fetch', (event)=>{\n    const start = performance.now();\n    event.respondWith(handleRequest(event.request).then((response)=>{\n        const duration = performance.now() - start;\n        // Log performance metrics\n        if (duration > 1000) console.log(`\\u{1F40C} Slow request: ${event.request.url} took ${duration}ms`);\n        return response;\n    }));\n});\nasync function handleRequest(request) {\n    // Default request handling logic\n    try {\n        return await fetch(request);\n    } catch (error) {\n        const cachedResponse = await caches.match(request);\n        return cachedResponse || new Response('Offline', {\n            status: 503\n        });\n    }\n}\nconsole.log(\"\\uD83D\\uDE80 PowerHouseATX Service Worker loaded\");\n\n//# sourceMappingURL=sw.js.map\n","/**\r\n * PowerHouseATX Service Worker\r\n * Provides offline functionality and caching for the training application\r\n */\r\n\r\nconst CACHE_NAME = 'powerhouseatx-v2.0.0';\r\nconst STATIC_CACHE = 'powerhouseatx-static-v2.0.0';\r\nconst DYNAMIC_CACHE = 'powerhouseatx-dynamic-v2.0.0';\r\n\r\n// Files to cache for offline functionality\r\nconst STATIC_FILES = [\r\n  '/',\r\n  '/index.html',\r\n  '/test-next-generation.html',\r\n  '/test-advanced-intelligence.html',\r\n  '/css/enhancedAdvanced.css',\r\n  '/js/core/trainingState.js',\r\n  '/js/algorithms/volume.js',\r\n  '/js/algorithms/effort.js',\r\n  '/js/algorithms/fatigue.js',\r\n  '/js/algorithms/analytics.js',\r\n  '/js/algorithms/exerciseSelection.js',\r\n  '/js/algorithms/livePerformance.js',\r\n  '/js/algorithms/intelligenceHub.js',\r\n  '/js/algorithms/dataVisualization.js',\r\n  '/js/algorithms/wellnessIntegration.js',\r\n  '/js/algorithms/periodizationSystem.js',\r\n  '/js/ui/feedbackFormUI.js',\r\n  '/js/ui/globals.js',\r\n  '/js/ui/enhancedAdvancedUI.js',\r\n  '/js/utils/dataExport.js',\r\n  '/js/utils/userFeedback.js',\r\n  '/manifest.json',\r\n  'https://cdn.jsdelivr.net/npm/chart.js'\r\n];\r\n\r\n// Files that should always be fetched fresh\r\nconst NETWORK_FIRST = [\r\n  '/js/utils/userFeedback.js',\r\n  '/js/utils/dataExport.js'\r\n];\r\n\r\n// Install event - cache static files\r\nself.addEventListener('install', event => {\r\n  console.log('🔧 Service Worker installing...');\r\n  \r\n  event.waitUntil(\r\n    Promise.all([\r\n      caches.open(STATIC_CACHE).then(cache => {\r\n        console.log('📦 Caching static files...');\r\n        return cache.addAll(STATIC_FILES.filter(url => !NETWORK_FIRST.includes(url)));\r\n      }),\r\n      caches.open(DYNAMIC_CACHE).then(cache => {\r\n        console.log('🔄 Dynamic cache initialized');\r\n        return cache;\r\n      })\r\n    ]).then(() => {\r\n      console.log('✅ Service Worker installation complete');\r\n      return self.skipWaiting();\r\n    })\r\n  );\r\n});\r\n\r\n// Activate event - cleanup old caches\r\nself.addEventListener('activate', event => {\r\n  console.log('🚀 Service Worker activating...');\r\n  \r\n  event.waitUntil(\r\n    caches.keys().then(cacheNames => {\r\n      return Promise.all(\r\n        cacheNames.map(cacheName => {\r\n          if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\r\n            console.log('🗑️ Deleting old cache:', cacheName);\r\n            return caches.delete(cacheName);\r\n          }\r\n        })\r\n      );\r\n    }).then(() => {\r\n      console.log('✅ Service Worker activation complete');\r\n      return self.clients.claim();\r\n    })\r\n  );\r\n});\r\n\r\n// Fetch event - serve cached content or fetch from network\r\nself.addEventListener('fetch', event => {\r\n  const { request } = event;\r\n  const url = new URL(request.url);\r\n  \r\n  // Handle different types of requests\r\n  if (request.method === 'GET') {\r\n    if (isStaticFile(request.url)) {\r\n      event.respondWith(cacheFirst(request));\r\n    } else if (isNetworkFirst(request.url)) {\r\n      event.respondWith(networkFirst(request));\r\n    } else if (isAnalyticsRequest(request.url)) {\r\n      event.respondWith(handleAnalyticsRequest(request));\r\n    } else {\r\n      event.respondWith(staleWhileRevalidate(request));\r\n    }\r\n  }\r\n});\r\n\r\n// Cache first strategy - for static files\r\nasync function cacheFirst(request) {\r\n  try {\r\n    const cachedResponse = await caches.match(request);\r\n    if (cachedResponse) {\r\n      return cachedResponse;\r\n    }\r\n    \r\n    const networkResponse = await fetch(request);\r\n    if (networkResponse.ok) {\r\n      const cache = await caches.open(STATIC_CACHE);\r\n      cache.put(request, networkResponse.clone());\r\n    }\r\n    \r\n    return networkResponse;\r\n  } catch (error) {\r\n    console.log('📡 Network failed, serving from cache or fallback:', error);\r\n    return await caches.match('/index.html') || new Response('Offline', { status: 503 });\r\n  }\r\n}\r\n\r\n// Network first strategy - for dynamic content\r\nasync function networkFirst(request) {\r\n  try {\r\n    const networkResponse = await fetch(request);\r\n    if (networkResponse.ok) {\r\n      const cache = await caches.open(DYNAMIC_CACHE);\r\n      cache.put(request, networkResponse.clone());\r\n    }\r\n    return networkResponse;\r\n  } catch (error) {\r\n    console.log('📡 Network failed, serving from cache:', error);\r\n    const cachedResponse = await caches.match(request);\r\n    return cachedResponse || new Response('Offline', { status: 503 });\r\n  }\r\n}\r\n\r\n// Stale while revalidate - for general content\r\nasync function staleWhileRevalidate(request) {\r\n  const cache = await caches.open(DYNAMIC_CACHE);\r\n  const cachedResponse = await cache.match(request);\r\n  \r\n  const fetchPromise = fetch(request).then(networkResponse => {\r\n    if (networkResponse.ok) {\r\n      cache.put(request, networkResponse.clone());\r\n    }\r\n    return networkResponse;\r\n  }).catch(error => {\r\n    console.log('📡 Network failed:', error);\r\n    return cachedResponse;\r\n  });\r\n  \r\n  return cachedResponse || await fetchPromise;\r\n}\r\n\r\n// Handle analytics requests (can work offline)\r\nasync function handleAnalyticsRequest(request) {\r\n  try {\r\n    return await fetch(request);\r\n  } catch (error) {\r\n    // Store analytics data locally when offline\r\n    const url = new URL(request.url);\r\n    const analyticsData = {\r\n      url: url.pathname,\r\n      timestamp: Date.now(),\r\n      offline: true\r\n    };\r\n    \r\n    // Store in IndexedDB or return success response\r\n    return new Response(JSON.stringify({ success: true, offline: true }), {\r\n      headers: { 'Content-Type': 'application/json' }\r\n    });\r\n  }\r\n}\r\n\r\n// Background sync for offline data\r\nself.addEventListener('sync', event => {\r\n  console.log('🔄 Background sync triggered:', event.tag);\r\n  \r\n  if (event.tag === 'background-sync-training-data') {\r\n    event.waitUntil(syncTrainingData());\r\n  } else if (event.tag === 'background-sync-feedback') {\r\n    event.waitUntil(syncFeedbackData());\r\n  }\r\n});\r\n\r\n// Sync training data when back online\r\nasync function syncTrainingData() {\r\n  console.log('📊 Syncing training data...');\r\n  \r\n  try {\r\n    // Get pending training data from localStorage\r\n    const pendingSessions = getPendingSessionData();\r\n    const pendingFeedback = getPendingFeedbackData();\r\n    \r\n    // Sync session data\r\n    for (const session of pendingSessions) {\r\n      await syncSession(session);\r\n    }\r\n    \r\n    // Sync feedback data\r\n    for (const feedback of pendingFeedback) {\r\n      await syncFeedback(feedback);\r\n    }\r\n    \r\n    console.log('✅ Training data sync complete');\r\n  } catch (error) {\r\n    console.error('❌ Training data sync failed:', error);\r\n  }\r\n}\r\n\r\n// Sync feedback data when back online\r\nasync function syncFeedbackData() {\r\n  console.log('💬 Syncing feedback data...');\r\n  \r\n  try {\r\n    const pendingFeedback = getPendingUserFeedback();\r\n    \r\n    for (const feedback of pendingFeedback) {\r\n      await syncUserFeedback(feedback);\r\n    }\r\n    \r\n    console.log('✅ Feedback sync complete');\r\n  } catch (error) {\r\n    console.error('❌ Feedback sync failed:', error);\r\n  }\r\n}\r\n\r\n// Push notifications for training reminders\r\nself.addEventListener('push', event => {\r\n  console.log('📢 Push notification received');\r\n  \r\n  const data = event.data ? event.data.json() : {};\r\n  const title = data.title || 'PowerHouseATX';\r\n  const options = {\r\n    body: data.body || 'Time for your training session!',\r\n    icon: '/icons/icon-192x192.png',\r\n    badge: '/icons/badge-72x72.png',\r\n    image: data.image,\r\n    data: data.data,\r\n    actions: [\r\n      {\r\n        action: 'start-session',\r\n        title: '🏋️ Start Session',\r\n        icon: '/icons/action-start.png'\r\n      },\r\n      {\r\n        action: 'postpone',\r\n        title: '⏰ Postpone',\r\n        icon: '/icons/action-postpone.png'\r\n      }\r\n    ],\r\n    requireInteraction: true,\r\n    vibrate: [200, 100, 200]\r\n  };\r\n  \r\n  event.waitUntil(\r\n    self.registration.showNotification(title, options)\r\n  );\r\n});\r\n\r\n// Handle notification clicks\r\nself.addEventListener('notificationclick', event => {\r\n  console.log('🖱️ Notification clicked:', event.action);\r\n  \r\n  event.notification.close();\r\n  \r\n  const action = event.action;\r\n  const data = event.notification.data || {};\r\n  \r\n  if (action === 'start-session') {\r\n    event.waitUntil(\r\n      clients.openWindow('/index.html#live-monitor')\r\n    );\r\n  } else if (action === 'postpone') {\r\n    // Schedule another reminder\r\n    scheduleTrainingReminder(30); // 30 minutes later\r\n  } else {\r\n    // Default action - open app\r\n    event.waitUntil(\r\n      clients.openWindow('/index.html')\r\n    );\r\n  }\r\n});\r\n\r\n// Message handling for communication with main app\r\nself.addEventListener('message', event => {\r\n  const { type, data } = event.data;\r\n  \r\n  switch (type) {\r\n    case 'SKIP_WAITING':\r\n      self.skipWaiting();\r\n      break;\r\n      \r\n    case 'GET_CACHE_STATUS':\r\n      event.ports[0].postMessage({\r\n        cacheStatus: getCacheStatus()\r\n      });\r\n      break;\r\n      \r\n    case 'CLEAR_CACHE':\r\n      clearAllCaches().then(() => {\r\n        event.ports[0].postMessage({ success: true });\r\n      });\r\n      break;\r\n      \r\n    case 'SCHEDULE_REMINDER':\r\n      scheduleTrainingReminder(data.minutes);\r\n      break;\r\n      \r\n    case 'REGISTER_BACKGROUND_SYNC':\r\n      registerBackgroundSync(data.tag);\r\n      break;\r\n  }\r\n});\r\n\r\n// Utility functions\r\nfunction isStaticFile(url) {\r\n  return STATIC_FILES.some(file => url.includes(file)) || \r\n         url.includes('.css') || \r\n         url.includes('.js') || \r\n         url.includes('.html');\r\n}\r\n\r\nfunction isNetworkFirst(url) {\r\n  return NETWORK_FIRST.some(file => url.includes(file));\r\n}\r\n\r\nfunction isAnalyticsRequest(url) {\r\n  return url.includes('analytics') || url.includes('feedback') || url.includes('tracking');\r\n}\r\n\r\nfunction getPendingSessionData() {\r\n  // This would integrate with the main app's localStorage\r\n  // For now, return empty array\r\n  return [];\r\n}\r\n\r\nfunction getPendingFeedbackData() {\r\n  // This would integrate with the main app's localStorage\r\n  return [];\r\n}\r\n\r\nfunction getPendingUserFeedback() {\r\n  // This would integrate with the feedback system\r\n  return [];\r\n}\r\n\r\nasync function syncSession(session) {\r\n  // Sync individual session to server\r\n  console.log('🔄 Syncing session:', session.id);\r\n}\r\n\r\nasync function syncFeedback(feedback) {\r\n  // Sync feedback to server\r\n  console.log('🔄 Syncing feedback:', feedback.id);\r\n}\r\n\r\nasync function syncUserFeedback(feedback) {\r\n  // Sync user feedback to server\r\n  console.log('🔄 Syncing user feedback:', feedback.id);\r\n}\r\n\r\nfunction getCacheStatus() {\r\n  return caches.keys().then(cacheNames => {\r\n    return {\r\n      caches: cacheNames,\r\n      version: CACHE_NAME\r\n    };\r\n  });\r\n}\r\n\r\nasync function clearAllCaches() {\r\n  const cacheNames = await caches.keys();\r\n  return Promise.all(\r\n    cacheNames.map(cacheName => caches.delete(cacheName))\r\n  );\r\n}\r\n\r\nfunction scheduleTrainingReminder(minutes) {\r\n  // Schedule a training reminder\r\n  console.log(`⏰ Training reminder scheduled for ${minutes} minutes`);\r\n}\r\n\r\nfunction registerBackgroundSync(tag) {\r\n  return self.registration.sync.register(tag);\r\n}\r\n\r\n// Performance monitoring\r\nself.addEventListener('fetch', event => {\r\n  const start = performance.now();\r\n  \r\n  event.respondWith(\r\n    handleRequest(event.request).then(response => {\r\n      const duration = performance.now() - start;\r\n      \r\n      // Log performance metrics\r\n      if (duration > 1000) { // Log slow requests\r\n        console.log(`🐌 Slow request: ${event.request.url} took ${duration}ms`);\r\n      }\r\n      \r\n      return response;\r\n    })\r\n  );\r\n});\r\n\r\nasync function handleRequest(request) {\r\n  // Default request handling logic\r\n  try {\r\n    return await fetch(request);\r\n  } catch (error) {\r\n    const cachedResponse = await caches.match(request);\r\n    return cachedResponse || new Response('Offline', { status: 503 });\r\n  }\r\n}\r\n\r\nconsole.log('🚀 PowerHouseATX Service Worker loaded');\r\n"],"names":["CACHE_NAME","STATIC_CACHE","DYNAMIC_CACHE","STATIC_FILES","NETWORK_FIRST","cacheFirst","request","cachedResponse","caches","match","networkResponse","fetch","ok","cache","open","put","clone","error","console","log","Response","status","networkFirst","staleWhileRevalidate","fetchPromise","then","catch","handleAnalyticsRequest","url","URL","pathname","Date","now","JSON","stringify","success","offline","headers","syncTrainingData","pendingSessions","getPendingSessionData","pendingFeedback","getPendingFeedbackData","session","syncSession","feedback","syncFeedback","syncFeedbackData","getPendingUserFeedback","syncUserFeedback","isStaticFile","some","file","includes","isNetworkFirst","isAnalyticsRequest","id","getCacheStatus","keys","cacheNames","version","clearAllCaches","Promise","all","map","cacheName","delete","scheduleTrainingReminder","minutes","registerBackgroundSync","tag","self","registration","sync","register","handleRequest","addEventListener","event","waitUntil","addAll","filter","skipWaiting","clients","claim","method","respondWith","data","json","title","options","body","icon","badge","image","actions","action","requireInteraction","vibrate","showNotification","notification","close","openWindow","type","ports","postMessage","cacheStatus","start","performance","response","duration"],"version":3,"file":"sw.js.map"}