{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,A,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,C,C,ECGC,IAAA,EAAA,EAAA,kD,E,iB,C,GAiZD,EAAA,MAAA,CAAA,EAAA,gBAAA,IACE,GADF,EAAA,MAAA,CAAA,EAAA,uBAAA,IAEE,GAFF,EAAA,MAAA,CAAA,EAAA,0BAAA,IAGE,GAHF,EAAA,MAAA,CAAA,EAAA,mBAAA,IAIE,GAJF,EAAA,MAAA,CAAA,EAAA,sBAAA,IAKE,GALF,EAAA,MAAA,CAAA,EAAA,0BAAA,IAME,GANF,EAAA,MAAA,CAAA,EAAA,sBAAA,IAOE,GAPF,EAAA,MAAA,CAAA,EAAA,uBAAA,IAQE,GARF,EAAA,MAAA,CAAA,EAAA,oBAAA,IASE,G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","sources":["<anon>","js/algorithms/volume.js","js/algorithms/fatigue.js"],"sourcesContent":["// modules are defined as an array\r\n// [ module function, map of requires ]\r\n//\r\n// map of requires is short require name -> numeric require\r\n//\r\n// anything defined in a previous bundle is accessed via the\r\n// orig method which is the require for previous bundles\r\n\r\n(function (\r\n  modules,\r\n  entry,\r\n  mainEntry,\r\n  parcelRequireName,\r\n  externals,\r\n  distDir,\r\n  publicUrl,\r\n  devServer\r\n) {\r\n  /* eslint-disable no-undef */\r\n  var globalObject =\r\n    typeof globalThis !== 'undefined'\r\n      ? globalThis\r\n      : typeof self !== 'undefined'\r\n      ? self\r\n      : typeof window !== 'undefined'\r\n      ? window\r\n      : typeof global !== 'undefined'\r\n      ? global\r\n      : {};\r\n  /* eslint-enable no-undef */\r\n\r\n  // Save the require from previous bundle to this closure if any\r\n  var previousRequire =\r\n    typeof globalObject[parcelRequireName] === 'function' &&\r\n    globalObject[parcelRequireName];\r\n\r\n  var importMap = previousRequire.i || {};\r\n  var cache = previousRequire.cache || {};\r\n  // Do not use `require` to prevent Webpack from trying to bundle this call\r\n  var nodeRequire =\r\n    typeof module !== 'undefined' &&\r\n    typeof module.require === 'function' &&\r\n    module.require.bind(module);\r\n\r\n  function newRequire(name, jumped) {\r\n    if (!cache[name]) {\r\n      if (!modules[name]) {\r\n        if (externals[name]) {\r\n          return externals[name];\r\n        }\r\n        // if we cannot find the module within our internal map or\r\n        // cache jump to the current global require ie. the last bundle\r\n        // that was added to the page.\r\n        var currentRequire =\r\n          typeof globalObject[parcelRequireName] === 'function' &&\r\n          globalObject[parcelRequireName];\r\n        if (!jumped && currentRequire) {\r\n          return currentRequire(name, true);\r\n        }\r\n\r\n        // If there are other bundles on this page the require from the\r\n        // previous one is saved to 'previousRequire'. Repeat this as\r\n        // many times as there are bundles until the module is found or\r\n        // we exhaust the require chain.\r\n        if (previousRequire) {\r\n          return previousRequire(name, true);\r\n        }\r\n\r\n        // Try the node require function if it exists.\r\n        if (nodeRequire && typeof name === 'string') {\r\n          return nodeRequire(name);\r\n        }\r\n\r\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\r\n        err.code = 'MODULE_NOT_FOUND';\r\n        throw err;\r\n      }\r\n\r\n      localRequire.resolve = resolve;\r\n      localRequire.cache = {};\r\n\r\n      var module = (cache[name] = new newRequire.Module(name));\r\n\r\n      modules[name][0].call(\r\n        module.exports,\r\n        localRequire,\r\n        module,\r\n        module.exports,\r\n        globalObject\r\n      );\r\n    }\r\n\r\n    return cache[name].exports;\r\n\r\n    function localRequire(x) {\r\n      var res = localRequire.resolve(x);\r\n      return res === false ? {} : newRequire(res);\r\n    }\r\n\r\n    function resolve(x) {\r\n      var id = modules[name][1][x];\r\n      return id != null ? id : x;\r\n    }\r\n  }\r\n\r\n  function Module(moduleName) {\r\n    this.id = moduleName;\r\n    this.bundle = newRequire;\r\n    this.require = nodeRequire;\r\n    this.exports = {};\r\n  }\r\n\r\n  newRequire.isParcelRequire = true;\r\n  newRequire.Module = Module;\r\n  newRequire.modules = modules;\r\n  newRequire.cache = cache;\r\n  newRequire.parent = previousRequire;\r\n  newRequire.distDir = distDir;\r\n  newRequire.publicUrl = publicUrl;\r\n  newRequire.devServer = devServer;\r\n  newRequire.i = importMap;\r\n  newRequire.register = function (id, exports) {\r\n    modules[id] = [\r\n      function (require, module) {\r\n        module.exports = exports;\r\n      },\r\n      {},\r\n    ];\r\n  };\r\n\r\n  // Only insert newRequire.load when it is actually used.\r\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\r\n  // INSERT_LOAD_HERE\r\n\r\n  Object.defineProperty(newRequire, 'root', {\r\n    get: function () {\r\n      return globalObject[parcelRequireName];\r\n    },\r\n  });\r\n\r\n  globalObject[parcelRequireName] = newRequire;\r\n\r\n  for (var i = 0; i < entry.length; i++) {\r\n    newRequire(entry[i]);\r\n  }\r\n\r\n  if (mainEntry) {\r\n    // Expose entry point to Node, AMD or browser globals\r\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\r\n    var mainExports = newRequire(mainEntry);\r\n\r\n    // CommonJS\r\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\r\n      module.exports = mainExports;\r\n\r\n      // RequireJS\r\n    } else if (typeof define === 'function' && define.amd) {\r\n      define(function () {\r\n        return mainExports;\r\n      });\r\n    }\r\n  }\r\n})({\"boGW6\":[function(require,module,exports,__globalThis) {\n/**\r\n * Renaissance Periodization Volume Algorithms\r\n * Implements RP Table 2.2 (MEV Stimulus Estimator) and Table 2.3 (Set Progression Algorithm)\r\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n// Export all functions\nparcelHelpers.export(exports, \"scoreStimulus\", ()=>scoreStimulus);\nparcelHelpers.export(exports, \"mevStimulusEstimator\", ()=>scoreStimulus);\nparcelHelpers.export(exports, \"setProgressionAlgorithm\", ()=>setProgressionAlgorithm);\nparcelHelpers.export(exports, \"rpSetProgression\", ()=>setProgressionAlgorithm);\nparcelHelpers.export(exports, \"analyzeVolumeStatus\", ()=>analyzeVolumeStatus);\nparcelHelpers.export(exports, \"calculateRecoveryVolume\", ()=>calculateRecoveryVolume);\nparcelHelpers.export(exports, \"validateVolumeInput\", ()=>validateVolumeInput);\nparcelHelpers.export(exports, \"getVolumeProgression\", ()=>getVolumeProgression);\nparcelHelpers.export(exports, \"analyzeDeloadNeed\", ()=>analyzeDeloadNeed);\nparcelHelpers.export(exports, \"autoSetIncrement\", ()=>autoSetIncrement);\nparcelHelpers.export(exports, \"processWeeklyVolumeProgression\", ()=>processWeeklyVolumeProgression);\nvar _trainingStateJs = require(\"../core/trainingState.js\");\nvar _trainingStateJsDefault = parcelHelpers.interopDefault(_trainingStateJs);\nvar _fatigueJs = require(\"./fatigue.js\");\n/**\r\n * RP Table 2.2: MEV Stimulus Estimator\r\n * Scores stimulus quality based on mind-muscle connection, pump, and disruption\r\n * @param {Object} feedback - {mmc: 0-3, pump: 0-3, disruption: 0-3}\r\n * @returns {Object} - {score: 0-9, advice: string, action: string}\r\n */ function scoreStimulus({ mmc, pump, disruption }) {\n    // Validate inputs\n    const clamp = (val, min, max)=>Math.max(min, Math.min(max, val));\n    const clampedMmc = clamp(mmc, 0, 3);\n    const clampedPump = clamp(pump, 0, 3);\n    const clampedDisruption = clamp(disruption, 0, 3);\n    const totalScore = clampedMmc + clampedPump + clampedDisruption;\n    let advice, action, setChange;\n    if (totalScore <= 3) {\n        advice = `Stimulus too low (${totalScore}/9) \\u{2192} Add 2 sets next session`;\n        action = 'add_sets';\n        setChange = 2;\n    } else if (totalScore <= 6) {\n        advice = `Stimulus adequate (${totalScore}/9) \\u{2192} Keep sets the same`;\n        action = 'maintain';\n        setChange = 0;\n    } else {\n        advice = `Stimulus excessive (${totalScore}/9) \\u{2192} Remove 1-2 sets next session`;\n        action = 'reduce_sets';\n        setChange = -1;\n    }\n    return {\n        score: totalScore,\n        advice,\n        action,\n        setChange,\n        breakdown: {\n            mmc: clampedMmc,\n            pump: clampedPump,\n            disruption: clampedDisruption\n        }\n    };\n}\n/**\r\n * Auto-Volume Progression System\r\n * Automatically increments sets based on MEV/MRV status and recovery feedback\r\n * @param {string} muscle - Target muscle group\r\n * @param {Object} feedback - {stimulus: 0-9, soreness: 0-3, perf: -1 to 2, recoverySession: boolean}\r\n * @param {Object} state - Training state singleton\r\n * @returns {Object} - {add: boolean, delta: number, reason: string}\r\n */ function autoSetIncrement(muscle, feedback, state) {\n    const { MEV, MRV } = state.volumeLandmarks[muscle];\n    const currentSets = state.currentWeekSets[muscle] || MEV;\n    const atMEV = currentSets <= MEV;\n    const atMRV = currentSets >= MRV;\n    const lowStimulus = feedback.stimulus <= 3;\n    const goodRecovery = feedback.soreness <= 1 && feedback.perf >= 0;\n    // Don't add if at MRV or recovery session needed\n    if (atMRV || feedback.recoverySession) return {\n        add: false,\n        delta: 0,\n        reason: atMRV ? 'At MRV - holding volume' : 'Recovery session needed'\n    };\n    // Add sets if at MEV or if low stimulus with good recovery\n    if (atMEV || lowStimulus && goodRecovery) {\n        const baseDelta = 1;\n        const mevBonus = atMEV ? 1 : 0; // Extra set boost when starting from MEV\n        const totalDelta = Math.min(baseDelta + mevBonus, 2); // Cap at +2 sets max\n        return {\n            add: true,\n            delta: totalDelta,\n            reason: atMEV ? 'Starting from MEV - aggressive progression' : 'Low stimulus with good recovery'\n        };\n    }\n    return {\n        add: false,\n        delta: 0,\n        reason: 'Maintaining current volume'\n    };\n}\n/**\r\n * Process weekly auto-volume progression for all muscles\r\n * @param {Object} weeklyFeedback - {muscle: {stimulus, soreness, perf, recoverySession}}\r\n * @param {Object} state - Training state singleton\r\n * @returns {Object} - Progression summary and deload recommendation\r\n */ function processWeeklyVolumeProgression(weeklyFeedback, state) {\n    const progressionLog = {};\n    let deloadTriggered = false;\n    let mrvHits = 0;\n    // Process each muscle's auto-progression\n    Object.keys(weeklyFeedback).forEach((muscle)=>{\n        const feedback = weeklyFeedback[muscle];\n        // Check for high fatigue using enhanced detection\n        const high = (0, _fatigueJs.isHighFatigue)(muscle, feedback, state);\n        if (high) {\n            // Treat like MRV - trigger recovery\n            state.hitMRV(muscle);\n            mrvHits++;\n            console.log(`hitMRV: true (fatigue) - ${muscle}`);\n            // Force recovery session\n            feedback.recoverySession = true;\n        }\n        const increment = autoSetIncrement(muscle, feedback, state);\n        // Apply set changes\n        if (increment.add) state.addSets(muscle, increment.delta);\n        // Track MRV hits for deload logic\n        if (state.getWeeklySets(muscle) >= state.volumeLandmarks[muscle].MRV) {\n            state.hitMRV(muscle);\n            mrvHits++;\n        }\n        progressionLog[muscle] = {\n            previousSets: state.lastWeekSets[muscle] || state.volumeLandmarks[muscle].MEV,\n            currentSets: state.getWeeklySets(muscle),\n            increment: increment.delta,\n            reason: increment.reason,\n            status: state.getVolumeStatus(muscle)\n        };\n    });\n    // Check deload conditions\n    if (state.shouldDeload()) {\n        state.startDeload();\n        deloadTriggered = true;\n    }\n    return {\n        progressionLog,\n        deloadTriggered,\n        mrvHits,\n        weekComplete: true,\n        recommendation: deloadTriggered ? 'Deload phase initiated' : 'Continue progression'\n    };\n}\n/**\r\n * RP Table 2.3: Set Progression Algorithm\r\n * Matrix lookup based on soreness level and performance vs last session\r\n * @param {number} soreness - 0-3 (0=none, 1=mild, 2=moderate, 3=high)\r\n * @param {number} performance - 0-3 (0=worse, 1=same, 2=better, 3=much better)\r\n * @returns {Object} - {advice: string, action: string, setChange: number}\r\n */ function setProgressionAlgorithm(soreness, performance) {\n    // Clamp inputs to valid ranges\n    const clamp = (val, min, max)=>Math.max(min, Math.min(max, val));\n    const s = clamp(soreness, 0, 3);\n    const p = clamp(performance, 0, 3);\n    // RP Set Progression Matrix [soreness][performance]\n    const progressionMatrix = [\n        // Soreness 0 (None)\n        [\n            {\n                advice: \"Add 1 set next session\",\n                action: \"add_sets\",\n                setChange: 1\n            },\n            {\n                advice: \"Add 2 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            },\n            {\n                advice: \"Add 2-3 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            },\n            {\n                advice: \"Add 2-3 sets next session\",\n                action: \"add_sets\",\n                setChange: 3\n            } // Performance 3 (much better)\n        ],\n        // Soreness 1 (Mild)\n        [\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            },\n            {\n                advice: \"Add 1 set next session\",\n                action: \"add_sets\",\n                setChange: 1\n            },\n            {\n                advice: \"Add 2 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            },\n            {\n                advice: \"Add 2-3 sets next session\",\n                action: \"add_sets\",\n                setChange: 2\n            } // Performance 3\n        ],\n        // Soreness 2 (Moderate)\n        [\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            },\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            },\n            {\n                advice: \"Add 1 set next session\",\n                action: \"add_sets\",\n                setChange: 1\n            } // Performance 3\n        ],\n        // Soreness 3 (High)\n        [\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Do recovery session\",\n                action: \"recovery\",\n                setChange: -99\n            },\n            {\n                advice: \"Hold sets at current level\",\n                action: \"maintain\",\n                setChange: 0\n            } // Performance 3\n        ]\n    ];\n    return progressionMatrix[s][p];\n}\n/**\r\n * Analyze current volume status relative to landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} currentSets - Current weekly sets (optional, uses state if not provided)\r\n * @returns {Object} - Volume analysis\r\n */ function analyzeVolumeStatus(muscle, currentSets = null) {\n    const sets = currentSets !== null ? currentSets : (0, _trainingStateJsDefault.default).currentWeekSets[muscle];\n    const landmarks = (0, _trainingStateJsDefault.default).volumeLandmarks[muscle];\n    if (!landmarks) throw new Error(`Unknown muscle group: ${muscle}`);\n    const status = (0, _trainingStateJsDefault.default).getVolumeStatus(muscle, sets);\n    const percentage = sets / landmarks.MRV * 100;\n    let recommendation = '';\n    let urgency = 'normal';\n    switch(status){\n        case 'under-minimum':\n            recommendation = `Below MV (${landmarks.MV}). Increase volume significantly.`;\n            urgency = 'high';\n            break;\n        case 'maintenance':\n            recommendation = `In maintenance zone (${landmarks.MV}-${landmarks.MEV}). Consider increasing for growth.`;\n            urgency = 'low';\n            break;\n        case 'optimal':\n            recommendation = `In optimal zone (${landmarks.MEV}-${landmarks.MAV}). Continue progressive overload.`;\n            urgency = 'normal';\n            break;\n        case 'high':\n            recommendation = `High volume zone (${landmarks.MAV}-${landmarks.MRV}). Monitor recovery closely.`;\n            urgency = 'medium';\n            break;\n        case 'maximum':\n            recommendation = `At/above MRV (${landmarks.MRV}). Deload recommended.`;\n            urgency = 'high';\n            break;\n    }\n    return {\n        muscle,\n        currentSets: sets,\n        landmarks,\n        status,\n        percentage: Math.round(percentage),\n        recommendation,\n        urgency,\n        color: (0, _trainingStateJsDefault.default).getVolumeColor(muscle, sets)\n    };\n}\n/**\r\n * Calculate recovery session volume\r\n * @param {string} muscle - Muscle group name\r\n * @param {boolean} hasIllness - Whether trainee has illness/injury\r\n * @returns {Object} - Recovery session recommendation\r\n */ function calculateRecoveryVolume(muscle, hasIllness = false) {\n    const landmarks = (0, _trainingStateJsDefault.default).volumeLandmarks[muscle];\n    const recoveryVolume = (0, _trainingStateJsDefault.default).getRecoveryVolume(muscle, hasIllness);\n    return {\n        muscle,\n        recommendedSets: recoveryVolume,\n        reasoning: hasIllness ? 'illness adjustment' : 'standard recovery',\n        landmarks,\n        percentage: Math.round(recoveryVolume / landmarks.MEV * 100)\n    };\n}\n/**\r\n * Validate volume input against landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} proposedSets - Proposed weekly sets\r\n * @returns {Object} - Validation result\r\n */ function validateVolumeInput(muscle, proposedSets) {\n    const landmarks = (0, _trainingStateJsDefault.default).volumeLandmarks[muscle];\n    const isValid = proposedSets >= 0 && proposedSets <= landmarks.MRV * 1.2; // Allow 20% over MRV\n    let warning = '';\n    if (proposedSets < 0) warning = 'Sets cannot be negative';\n    else if (proposedSets > landmarks.MRV) warning = `Above MRV (${landmarks.MRV}). Consider deload.`;\n    else if (proposedSets < landmarks.MV) warning = `Below MV (${landmarks.MV}). May not be sufficient for adaptation.`;\n    return {\n        isValid,\n        warning,\n        proposedSets,\n        landmarks\n    };\n}\n/**\r\n * Get volume progression recommendation for next week\r\n * @param {string} muscle - Muscle group name\r\n * @param {Object} feedback - Latest training feedback\r\n * @returns {Object} - Next week recommendation\r\n */ function getVolumeProgression(muscle, feedback) {\n    const currentSets = (0, _trainingStateJsDefault.default).currentWeekSets[muscle];\n    const volumeAnalysis = analyzeVolumeStatus(muscle);\n    // Get stimulus score\n    const stimulusResult = scoreStimulus(feedback.stimulus);\n    // Get set progression recommendation\n    const progressionResult = setProgressionAlgorithm(feedback.soreness, feedback.performance);\n    // Combine recommendations with volume constraints\n    let finalSetChange = progressionResult.setChange;\n    let finalAdvice = progressionResult.advice;\n    // Override if at volume limits\n    if (volumeAnalysis.status === 'maximum' && finalSetChange > 0) {\n        finalSetChange = 0;\n        finalAdvice = \"At MRV limit. Hold sets or consider deload.\";\n    }\n    if (volumeAnalysis.status === 'under-minimum' && finalSetChange <= 0) {\n        finalSetChange = 2;\n        finalAdvice = \"Below minimum volume. Add sets regardless of fatigue.\";\n    }\n    // Special handling for recovery sessions\n    if (progressionResult.action === 'recovery') {\n        const recoveryVolume = calculateRecoveryVolume(muscle, feedback.hasIllness);\n        finalSetChange = recoveryVolume.recommendedSets - currentSets;\n        finalAdvice = `Recovery session: ${recoveryVolume.recommendedSets} sets (${recoveryVolume.reasoning})`;\n    }\n    const projectedSets = Math.max(0, currentSets + finalSetChange);\n    return {\n        muscle,\n        currentSets,\n        projectedSets,\n        setChange: finalSetChange,\n        advice: finalAdvice,\n        stimulusScore: stimulusResult.score,\n        volumeStatus: volumeAnalysis.status,\n        targetRIR: (0, _trainingStateJsDefault.default).getTargetRIR(),\n        deloadRecommended: (0, _trainingStateJsDefault.default).shouldDeload()\n    };\n}\n/**\r\n * Analyze all muscles for deload necessity\r\n * @returns {Object} - Deload analysis\r\n */ function analyzeDeloadNeed() {\n    const muscles = Object.keys((0, _trainingStateJsDefault.default).volumeLandmarks);\n    const mrvBreaches = muscles.filter((muscle)=>(0, _trainingStateJsDefault.default).getVolumeStatus(muscle) === 'maximum');\n    const shouldDeload = (0, _trainingStateJsDefault.default).shouldDeload();\n    const reasons = [];\n    if ((0, _trainingStateJsDefault.default).consecutiveMRVWeeks >= 2) reasons.push('Two consecutive weeks at MRV');\n    if ((0, _trainingStateJsDefault.default).totalMusclesNeedingRecovery >= Math.ceil(muscles.length / 2)) reasons.push('Most muscles need recovery sessions');\n    if ((0, _trainingStateJsDefault.default).weekNo >= (0, _trainingStateJsDefault.default).mesoLen) reasons.push('End of mesocycle reached');\n    if (mrvBreaches.length >= Math.ceil(muscles.length / 3)) reasons.push(`${mrvBreaches.length} muscle groups at/above MRV`);\n    return {\n        shouldDeload,\n        reasons,\n        mrvBreaches,\n        consecutiveMRVWeeks: (0, _trainingStateJsDefault.default).consecutiveMRVWeeks,\n        currentWeek: (0, _trainingStateJsDefault.default).weekNo,\n        mesoLength: (0, _trainingStateJsDefault.default).mesoLen,\n        musclesNeedingRecovery: (0, _trainingStateJsDefault.default).totalMusclesNeedingRecovery\n    };\n}\n\n},{\"../core/trainingState.js\":\"e7afj\",\"./fatigue.js\":\"3GKzs\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}],\"3GKzs\":[function(require,module,exports,__globalThis) {\n/**\r\n * Renaissance Periodization Fatigue Management\r\n * Handles recovery monitoring, frequency optimization, and fatigue accumulation\r\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"analyzeFrequency\", ()=>analyzeFrequency);\nparcelHelpers.export(exports, \"calculateOptimalFrequency\", ()=>calculateOptimalFrequency);\nparcelHelpers.export(exports, \"isHighFatigue\", ()=>isHighFatigue);\nvar _trainingStateJs = require(\"../core/trainingState.js\");\nvar _trainingStateJsDefault = parcelHelpers.interopDefault(_trainingStateJs);\n/**\r\n * Analyze recovery status and frequency optimization\r\n * @param {number} sorenessRecoveryDays - Days until soreness is gone\r\n * @param {number} currentSessionGap - Days between sessions for this muscle\r\n * @param {string} muscle - Muscle group name\r\n * @returns {Object} - Frequency analysis\r\n */ function analyzeFrequency(sorenessRecoveryDays, currentSessionGap, muscle = null) {\n    const recoveryTime = Math.max(0, sorenessRecoveryDays);\n    const sessionGap = Math.max(1, currentSessionGap);\n    let recommendation = '';\n    let action = '';\n    let urgency = 'normal';\n    let frequencyAdjustment = 0;\n    // Recovery vs session gap analysis\n    const recoveryRatio = recoveryTime / sessionGap;\n    if (recoveryRatio < 0.7) {\n        // Recovering much faster than session frequency\n        recommendation = \"You heal early \\u2192 Add one session per week\";\n        action = 'increase_frequency';\n        frequencyAdjustment = 1;\n        urgency = 'medium';\n    } else if (recoveryRatio > 1.3) {\n        // Still sore when next session is due\n        recommendation = \"Recovery lags \\u2192 Insert an extra rest day\";\n        action = 'decrease_frequency';\n        frequencyAdjustment = -1;\n        urgency = 'high';\n    } else {\n        // Optimal recovery timing\n        recommendation = 'Frequency is optimal';\n        action = 'maintain';\n        frequencyAdjustment = 0;\n        urgency = 'normal';\n    }\n    // Consider current volume when making frequency recommendations\n    if (muscle) {\n        const volumeStatus = (0, _trainingStateJsDefault.default).getVolumeStatus(muscle);\n        if (volumeStatus === 'maximum' && action === 'increase_frequency') {\n            recommendation = 'At MRV - maintain frequency despite early recovery';\n            action = 'maintain';\n            frequencyAdjustment = 0;\n        }\n        if (volumeStatus === 'under-minimum' && action === 'decrease_frequency') {\n            recommendation = 'Below MV - consider recovery methods instead of reducing frequency';\n            action = 'improve_recovery';\n            frequencyAdjustment = 0;\n        }\n    }\n    return {\n        sorenessRecoveryDays: recoveryTime,\n        currentSessionGap: sessionGap,\n        recoveryRatio: Math.round(recoveryRatio * 100) / 100,\n        recommendation,\n        action,\n        frequencyAdjustment,\n        urgency,\n        muscle\n    };\n}\n/**\r\n * Assess overall fatigue accumulation\r\n * @param {Object} weeklyData - Weekly fatigue metrics\r\n * @returns {Object} - Fatigue assessment\r\n */ function assessFatigueAccumulation(weeklyData) {\n    const { averageSoreness = 1, sleepQuality = 7, stressLevel = 5, musclesNeedingRecovery = 0, consecutiveMRVWeeks = 0, performanceDecline = false } = weeklyData;\n    // Calculate fatigue score (0-100)\n    let fatigueScore = 0;\n    // Soreness contribution (0-30 points)\n    fatigueScore += Math.min(30, averageSoreness / 3 * 30);\n    // Sleep quality contribution (0-20 points, inverted)\n    fatigueScore += Math.max(0, 20 - sleepQuality / 10 * 20);\n    // Stress level contribution (0-20 points)\n    fatigueScore += stressLevel / 10 * 20;\n    // Volume overreaching contribution (0-20 points)\n    const volumeOverreach = Math.min(20, musclesNeedingRecovery / 12 * 20);\n    fatigueScore += volumeOverreach;\n    // Consecutive MRV weeks (0-10 points)\n    fatigueScore += Math.min(10, consecutiveMRVWeeks * 5);\n    // Performance decline bonus\n    if (performanceDecline) fatigueScore += 10;\n    // Determine fatigue level\n    let fatigueLevel = '';\n    let recommendations = [];\n    let deloadUrgency = 'none';\n    if (fatigueScore <= 25) {\n        fatigueLevel = 'low';\n        recommendations.push('Continue current program');\n        recommendations.push('Consider volume progression opportunities');\n    } else if (fatigueScore <= 50) {\n        fatigueLevel = 'moderate';\n        recommendations.push('Monitor recovery closely');\n        recommendations.push('Ensure adequate sleep and nutrition');\n        deloadUrgency = 'low';\n    } else if (fatigueScore <= 75) {\n        fatigueLevel = 'high';\n        recommendations.push('Reduce training stress');\n        recommendations.push('Consider recovery week');\n        recommendations.push('Prioritize sleep and stress management');\n        deloadUrgency = 'medium';\n    } else {\n        fatigueLevel = 'excessive';\n        recommendations.push('Implement deload immediately');\n        recommendations.push('Address sleep and lifestyle factors');\n        recommendations.push('Consider extending deload period');\n        deloadUrgency = 'high';\n    }\n    return {\n        fatigueScore: Math.round(fatigueScore),\n        fatigueLevel,\n        recommendations,\n        deloadUrgency,\n        breakdown: {\n            soreness: Math.min(30, averageSoreness / 3 * 30),\n            sleep: Math.max(0, 20 - sleepQuality / 10 * 20),\n            stress: stressLevel / 10 * 20,\n            volume: volumeOverreach,\n            consecutive: Math.min(10, consecutiveMRVWeeks * 5),\n            performance: performanceDecline ? 10 : 0\n        }\n    };\n}\n/**\r\n * Generate recovery session recommendations\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} options - Recovery options\r\n * @returns {Object} - Recovery session plan\r\n */ function generateRecoverySession(muscle, options = {}) {\n    const { hasIllness = false, sorenessLevel = 2, lastSessionRIR = 0, preferredRecoveryType = 'volume' } = options;\n    const landmarks = (0, _trainingStateJsDefault.default).volumeLandmarks[muscle];\n    const baseRecoveryVolume = (0, _trainingStateJsDefault.default).getRecoveryVolume(muscle, hasIllness);\n    let recoveryPlan = {\n        muscle,\n        type: preferredRecoveryType,\n        sets: baseRecoveryVolume,\n        intensity: '60-70% of normal',\n        rirTarget: '3-4 RIR',\n        duration: '1 session',\n        notes: []\n    };\n    // Adjust based on soreness level\n    if (sorenessLevel >= 3) {\n        recoveryPlan.sets = Math.round(baseRecoveryVolume * 0.7);\n        recoveryPlan.intensity = '50-60% of normal';\n        recoveryPlan.rirTarget = '4-5 RIR';\n        recoveryPlan.notes.push('High soreness - very light session');\n    }\n    // Adjust for illness\n    if (hasIllness) {\n        recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\n        recoveryPlan.intensity = '40-50% of normal';\n        recoveryPlan.notes.push('Illness present - prioritize rest');\n    }\n    // Adjust based on last session intensity\n    if (lastSessionRIR <= 0.5) {\n        recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\n        recoveryPlan.notes.push('Last session was very intense');\n    }\n    // Recovery type specific adjustments\n    if (preferredRecoveryType === 'deload') {\n        recoveryPlan.sets = Math.round(landmarks.MEV * 0.5);\n        recoveryPlan.intensity = '40-50% of normal';\n        recoveryPlan.duration = '3-7 days';\n        recoveryPlan.notes.push('Full deload protocol');\n    }\n    return recoveryPlan;\n}\n/**\r\n * Monitor overreaching vs overtraining risk\r\n * @param {Object} metrics - Training metrics over time\r\n * @returns {Object} - Risk assessment\r\n */ function assessOverreachingRisk(metrics) {\n    const { weeklyPerformanceTrend = [], weeklyFatigueTrend = [], volumeProgression = [], motivationLevel = 5, injuryRisk = 1 // 1-10\n     } = metrics;\n    let riskScore = 0;\n    let riskFactors = [];\n    // Performance trend analysis\n    if (weeklyPerformanceTrend.length >= 2) {\n        const recentTrend = weeklyPerformanceTrend.slice(-3);\n        const isDecreasing = recentTrend.every((val, i)=>i === 0 || val <= recentTrend[i - 1]);\n        if (isDecreasing) {\n            riskScore += 20;\n            riskFactors.push('Consistent performance decline');\n        }\n    }\n    // Fatigue accumulation\n    if (weeklyFatigueTrend.length >= 2) {\n        const avgFatigue = weeklyFatigueTrend.reduce((a, b)=>a + b, 0) / weeklyFatigueTrend.length;\n        if (avgFatigue > 60) {\n            riskScore += 25;\n            riskFactors.push('High average fatigue');\n        }\n    }\n    // Volume progression rate\n    if (volumeProgression.length >= 3) {\n        const volumeIncrease = volumeProgression[volumeProgression.length - 1] - volumeProgression[0];\n        const weekSpan = volumeProgression.length;\n        const weeklyIncrease = volumeIncrease / weekSpan;\n        if (weeklyIncrease > 2) {\n            riskScore += 15;\n            riskFactors.push('Rapid volume progression');\n        }\n    }\n    // Motivation and wellbeing\n    if (motivationLevel <= 3) {\n        riskScore += 15;\n        riskFactors.push('Low motivation/enjoyment');\n    }\n    // Injury risk\n    if (injuryRisk >= 7) {\n        riskScore += 15;\n        riskFactors.push('High injury risk indicators');\n    }\n    // Current training state\n    if ((0, _trainingStateJsDefault.default).consecutiveMRVWeeks >= 2) {\n        riskScore += 10;\n        riskFactors.push('Consecutive weeks at MRV');\n    }\n    // Determine risk level\n    let riskLevel = '';\n    let recommendations = [];\n    if (riskScore <= 20) {\n        riskLevel = 'low';\n        recommendations.push('Continue progressive overload');\n        recommendations.push('Monitor for early warning signs');\n    } else if (riskScore <= 40) {\n        riskLevel = 'moderate';\n        recommendations.push('Slow progression rate');\n        recommendations.push('Increase recovery focus');\n        recommendations.push('Consider planned deload');\n    } else if (riskScore <= 70) {\n        riskLevel = 'high';\n        recommendations.push('Implement deload week');\n        recommendations.push('Address lifestyle stressors');\n        recommendations.push('Reduce training frequency');\n    } else {\n        riskLevel = 'critical';\n        recommendations.push('Stop training temporarily');\n        recommendations.push('Focus on full recovery');\n        recommendations.push('Consult with coach/healthcare provider');\n    }\n    return {\n        riskScore,\n        riskLevel,\n        riskFactors,\n        recommendations,\n        requiresImmediateAction: riskScore > 60\n    };\n}\n/**\r\n * Calculate optimal session frequency for a muscle\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} constraints - Training constraints\r\n * @returns {Object} - Frequency recommendation\r\n */ function calculateOptimalFrequency(muscle, constraints = {}) {\n    const { availableDays = 6, currentVolume = null, recoveryCapacity = 'normal', trainingAge = 'intermediate' // beginner, intermediate, advanced\n     } = constraints;\n    const volume = currentVolume || (0, _trainingStateJsDefault.default).currentWeekSets[muscle];\n    const landmarks = (0, _trainingStateJsDefault.default).volumeLandmarks[muscle];\n    // Base frequency recommendations by training age\n    const baseFrequencies = {\n        beginner: {\n            min: 2,\n            max: 3\n        },\n        intermediate: {\n            min: 2,\n            max: 4\n        },\n        advanced: {\n            min: 3,\n            max: 5\n        }\n    };\n    const ageRecommendation = baseFrequencies[trainingAge];\n    // Adjust for volume\n    let volumeFrequency = 2;\n    if (volume >= landmarks.MAV) volumeFrequency = Math.min(4, Math.ceil(volume / 6)); // ~6 sets per session max at high volumes\n    else if (volume >= landmarks.MEV) volumeFrequency = Math.min(3, Math.ceil(volume / 8)); // ~8 sets per session\n    else volumeFrequency = Math.max(2, Math.ceil(volume / 10)); // ~10 sets per session at lower volumes\n    // Adjust for recovery capacity\n    const recoveryMultipliers = {\n        low: 0.8,\n        normal: 1.0,\n        high: 1.2\n    };\n    const adjustedFrequency = Math.round(volumeFrequency * recoveryMultipliers[recoveryCapacity]);\n    // Constrain to available days and training age limits\n    const recommendedFrequency = Math.max(ageRecommendation.min, Math.min(ageRecommendation.max, adjustedFrequency, availableDays));\n    // Calculate sets per session\n    const setsPerSession = Math.ceil(volume / recommendedFrequency);\n    return {\n        muscle,\n        recommendedFrequency,\n        setsPerSession,\n        totalVolume: volume,\n        reasoning: [\n            `${volume} weekly sets`,\n            `${recoveryCapacity} recovery capacity`,\n            `${trainingAge} training age`,\n            `${availableDays} available days`\n        ],\n        alternatives: {\n            conservative: Math.max(2, recommendedFrequency - 1),\n            aggressive: Math.min(availableDays, recommendedFrequency + 1)\n        }\n    };\n}\n/**\r\n * Enhanced fatigue detection using SFR and rep strength drop\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} feedback - Feedback data with soreness, jointAche, perfChange, stimulus, lastLoad\r\n * @param {Object} state - Training state singleton\r\n * @returns {boolean} - True if high fatigue detected\r\n */ function isHighFatigue(muscle, feedback, state) {\n    // Calculate total fatigue score\n    const soreness = feedback.soreness || 0;\n    const jointAche = feedback.jointAche || 0;\n    const perfChange = feedback.perfChange || 0;\n    // Fatigue components: soreness + joint ache + performance decline penalty\n    const fatigue = soreness + jointAche + (perfChange < 0 ? 2 : 0);\n    // Stimulus components: pump + disruption (mind-muscle connection less relevant for fatigue)\n    const stimulus = (feedback.pump || 0) + (feedback.disruption || 0);\n    // Calculate Stimulus-to-Fatigue Ratio (SFR)\n    const SFR = stimulus / (fatigue || 1); // Avoid zero division\n    // Check for rep strength drop\n    const strengthDrop = feedback.lastLoad ? state.repStrengthDrop(muscle, feedback.lastLoad) : false;\n    // High fatigue if SFR ≤ 1 OR strength drop detected\n    return SFR <= 1 || strengthDrop;\n}\n\n},{\"../core/trainingState.js\":\"e7afj\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}]},[\"boGW6\"], \"boGW6\", \"parcelRequire66c8\", {})\n\n//# sourceMappingURL=volume.43331bd9.js.map\n","/**\r\n * Renaissance Periodization Volume Algorithms\r\n * Implements RP Table 2.2 (MEV Stimulus Estimator) and Table 2.3 (Set Progression Algorithm)\r\n */\r\n\r\nimport trainingState from '../core/trainingState.js';\r\nimport { isHighFatigue } from './fatigue.js';\r\n\r\n/**\r\n * RP Table 2.2: MEV Stimulus Estimator\r\n * Scores stimulus quality based on mind-muscle connection, pump, and disruption\r\n * @param {Object} feedback - {mmc: 0-3, pump: 0-3, disruption: 0-3}\r\n * @returns {Object} - {score: 0-9, advice: string, action: string}\r\n */\r\nfunction scoreStimulus({ mmc, pump, disruption }) {\r\n  // Validate inputs\r\n  const clamp = (val, min, max) => Math.max(min, Math.min(max, val));\r\n  const clampedMmc = clamp(mmc, 0, 3);\r\n  const clampedPump = clamp(pump, 0, 3);\r\n  const clampedDisruption = clamp(disruption, 0, 3);\r\n  \r\n  const totalScore = clampedMmc + clampedPump + clampedDisruption;\r\n  \r\n  let advice, action, setChange;\r\n  \r\n  if (totalScore <= 3) {\r\n    advice = `Stimulus too low (${totalScore}/9) → Add 2 sets next session`;\r\n    action = 'add_sets';\r\n    setChange = 2;\r\n  } else if (totalScore <= 6) {\r\n    advice = `Stimulus adequate (${totalScore}/9) → Keep sets the same`;\r\n    action = 'maintain';\r\n    setChange = 0;\r\n  } else {\r\n    advice = `Stimulus excessive (${totalScore}/9) → Remove 1-2 sets next session`;\r\n    action = 'reduce_sets';\r\n    setChange = -1;\r\n  }\r\n  \r\n  return {\r\n    score: totalScore,\r\n    advice,\r\n    action,\r\n    setChange,\r\n    breakdown: {\r\n      mmc: clampedMmc,\r\n      pump: clampedPump,\r\n      disruption: clampedDisruption\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Auto-Volume Progression System\r\n * Automatically increments sets based on MEV/MRV status and recovery feedback\r\n * @param {string} muscle - Target muscle group\r\n * @param {Object} feedback - {stimulus: 0-9, soreness: 0-3, perf: -1 to 2, recoverySession: boolean}\r\n * @param {Object} state - Training state singleton\r\n * @returns {Object} - {add: boolean, delta: number, reason: string}\r\n */\r\nfunction autoSetIncrement(muscle, feedback, state) {\r\n  const { MEV, MRV } = state.volumeLandmarks[muscle];\r\n  const currentSets = state.currentWeekSets[muscle] || MEV;\r\n  \r\n  const atMEV = currentSets <= MEV;\r\n  const atMRV = currentSets >= MRV;\r\n  const lowStimulus = feedback.stimulus <= 3;\r\n  const goodRecovery = feedback.soreness <= 1 && feedback.perf >= 0;\r\n  \r\n  // Don't add if at MRV or recovery session needed\r\n  if (atMRV || feedback.recoverySession) {\r\n    return { \r\n      add: false, \r\n      delta: 0, \r\n      reason: atMRV ? 'At MRV - holding volume' : 'Recovery session needed' \r\n    };\r\n  }\r\n  \r\n  // Add sets if at MEV or if low stimulus with good recovery\r\n  if (atMEV || (lowStimulus && goodRecovery)) {\r\n    const baseDelta = 1;\r\n    const mevBonus = atMEV ? 1 : 0; // Extra set boost when starting from MEV\r\n    const totalDelta = Math.min(baseDelta + mevBonus, 2); // Cap at +2 sets max\r\n    \r\n    return { \r\n      add: true, \r\n      delta: totalDelta,\r\n      reason: atMEV ? 'Starting from MEV - aggressive progression' : 'Low stimulus with good recovery'\r\n    };\r\n  }\r\n  \r\n  return { \r\n    add: false, \r\n    delta: 0, \r\n    reason: 'Maintaining current volume' \r\n  };\r\n}\r\n\r\n/**\r\n * Process weekly auto-volume progression for all muscles\r\n * @param {Object} weeklyFeedback - {muscle: {stimulus, soreness, perf, recoverySession}}\r\n * @param {Object} state - Training state singleton\r\n * @returns {Object} - Progression summary and deload recommendation\r\n */\r\nfunction processWeeklyVolumeProgression(weeklyFeedback, state) {\r\n  const progressionLog = {};\r\n  let deloadTriggered = false;\r\n  let mrvHits = 0;\r\n  // Process each muscle's auto-progression\r\n  Object.keys(weeklyFeedback).forEach(muscle => {\r\n    const feedback = weeklyFeedback[muscle];\r\n    \r\n    // Check for high fatigue using enhanced detection\r\n    const high = isHighFatigue(muscle, feedback, state);\r\n    if (high) {\r\n      // Treat like MRV - trigger recovery\r\n      state.hitMRV(muscle);\r\n      mrvHits++;\r\n      console.log(`hitMRV: true (fatigue) - ${muscle}`);\r\n      \r\n      // Force recovery session\r\n      feedback.recoverySession = true;\r\n    }\r\n    \r\n    const increment = autoSetIncrement(muscle, feedback, state);\r\n    \r\n    // Apply set changes\r\n    if (increment.add) {\r\n      state.addSets(muscle, increment.delta);\r\n    }\r\n    \r\n    // Track MRV hits for deload logic\r\n    if (state.getWeeklySets(muscle) >= state.volumeLandmarks[muscle].MRV) {\r\n      state.hitMRV(muscle);\r\n      mrvHits++;\r\n    }\r\n    \r\n    progressionLog[muscle] = {\r\n      previousSets: state.lastWeekSets[muscle] || state.volumeLandmarks[muscle].MEV,\r\n      currentSets: state.getWeeklySets(muscle),\r\n      increment: increment.delta,\r\n      reason: increment.reason,\r\n      status: state.getVolumeStatus(muscle)\r\n    };\r\n  });\r\n\r\n  // Check deload conditions\r\n  if (state.shouldDeload()) {\r\n    state.startDeload();\r\n    deloadTriggered = true;\r\n  }\r\n\r\n  return {\r\n    progressionLog,\r\n    deloadTriggered,\r\n    mrvHits,\r\n    weekComplete: true,\r\n    recommendation: deloadTriggered ? 'Deload phase initiated' : 'Continue progression'\r\n  };\r\n}\r\n\r\n/**\r\n * RP Table 2.3: Set Progression Algorithm\r\n * Matrix lookup based on soreness level and performance vs last session\r\n * @param {number} soreness - 0-3 (0=none, 1=mild, 2=moderate, 3=high)\r\n * @param {number} performance - 0-3 (0=worse, 1=same, 2=better, 3=much better)\r\n * @returns {Object} - {advice: string, action: string, setChange: number}\r\n */\r\nfunction setProgressionAlgorithm(soreness, performance) {\r\n  // Clamp inputs to valid ranges\r\n  const clamp = (val, min, max) => Math.max(min, Math.min(max, val));\r\n  const s = clamp(soreness, 0, 3);\r\n  const p = clamp(performance, 0, 3);\r\n  \r\n  // RP Set Progression Matrix [soreness][performance]\r\n  const progressionMatrix = [\r\n    // Soreness 0 (None)\r\n    [\r\n      { advice: \"Add 1 set next session\", action: \"add_sets\", setChange: 1 },      // Performance 0 (worse)\r\n      { advice: \"Add 2 sets next session\", action: \"add_sets\", setChange: 2 },     // Performance 1 (same)\r\n      { advice: \"Add 2-3 sets next session\", action: \"add_sets\", setChange: 2 },   // Performance 2 (better)\r\n      { advice: \"Add 2-3 sets next session\", action: \"add_sets\", setChange: 3 }    // Performance 3 (much better)\r\n    ],\r\n    // Soreness 1 (Mild)\r\n    [\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 },  // Performance 0\r\n      { advice: \"Add 1 set next session\", action: \"add_sets\", setChange: 1 },      // Performance 1\r\n      { advice: \"Add 2 sets next session\", action: \"add_sets\", setChange: 2 },     // Performance 2\r\n      { advice: \"Add 2-3 sets next session\", action: \"add_sets\", setChange: 2 }    // Performance 3\r\n    ],\r\n    // Soreness 2 (Moderate)\r\n    [\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 0\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 },  // Performance 1\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 },  // Performance 2\r\n      { advice: \"Add 1 set next session\", action: \"add_sets\", setChange: 1 }       // Performance 3\r\n    ],\r\n    // Soreness 3 (High)\r\n    [\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 0\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 1\r\n      { advice: \"Do recovery session\", action: \"recovery\", setChange: -99 },       // Performance 2\r\n      { advice: \"Hold sets at current level\", action: \"maintain\", setChange: 0 }   // Performance 3\r\n    ]\r\n  ];\r\n  \r\n  return progressionMatrix[s][p];\r\n}\r\n\r\n/**\r\n * Analyze current volume status relative to landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} currentSets - Current weekly sets (optional, uses state if not provided)\r\n * @returns {Object} - Volume analysis\r\n */\r\nfunction analyzeVolumeStatus(muscle, currentSets = null) {\r\n  const sets = currentSets !== null ? currentSets : trainingState.currentWeekSets[muscle];\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  \r\n  if (!landmarks) {\r\n    throw new Error(`Unknown muscle group: ${muscle}`);\r\n  }\r\n  \r\n  const status = trainingState.getVolumeStatus(muscle, sets);\r\n  const percentage = (sets / landmarks.MRV) * 100;\r\n  \r\n  let recommendation = '';\r\n  let urgency = 'normal';\r\n  \r\n  switch (status) {\r\n    case 'under-minimum':\r\n      recommendation = `Below MV (${landmarks.MV}). Increase volume significantly.`;\r\n      urgency = 'high';\r\n      break;\r\n    case 'maintenance':\r\n      recommendation = `In maintenance zone (${landmarks.MV}-${landmarks.MEV}). Consider increasing for growth.`;\r\n      urgency = 'low';\r\n      break;\r\n    case 'optimal':\r\n      recommendation = `In optimal zone (${landmarks.MEV}-${landmarks.MAV}). Continue progressive overload.`;\r\n      urgency = 'normal';\r\n      break;\r\n    case 'high':\r\n      recommendation = `High volume zone (${landmarks.MAV}-${landmarks.MRV}). Monitor recovery closely.`;\r\n      urgency = 'medium';\r\n      break;\r\n    case 'maximum':\r\n      recommendation = `At/above MRV (${landmarks.MRV}). Deload recommended.`;\r\n      urgency = 'high';\r\n      break;\r\n  }\r\n  \r\n  return {\r\n    muscle,\r\n    currentSets: sets,\r\n    landmarks,\r\n    status,\r\n    percentage: Math.round(percentage),\r\n    recommendation,\r\n    urgency,\r\n    color: trainingState.getVolumeColor(muscle, sets)\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate recovery session volume\r\n * @param {string} muscle - Muscle group name\r\n * @param {boolean} hasIllness - Whether trainee has illness/injury\r\n * @returns {Object} - Recovery session recommendation\r\n */\r\nfunction calculateRecoveryVolume(muscle, hasIllness = false) {\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  const recoveryVolume = trainingState.getRecoveryVolume(muscle, hasIllness);\r\n  \r\n  return {\r\n    muscle,\r\n    recommendedSets: recoveryVolume,\r\n    reasoning: hasIllness ? 'illness adjustment' : 'standard recovery',\r\n    landmarks,\r\n    percentage: Math.round((recoveryVolume / landmarks.MEV) * 100)\r\n  };\r\n}\r\n\r\n/**\r\n * Validate volume input against landmarks\r\n * @param {string} muscle - Muscle group name\r\n * @param {number} proposedSets - Proposed weekly sets\r\n * @returns {Object} - Validation result\r\n */\r\nfunction validateVolumeInput(muscle, proposedSets) {\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  const isValid = proposedSets >= 0 && proposedSets <= landmarks.MRV * 1.2; // Allow 20% over MRV\r\n  \r\n  let warning = '';\r\n  if (proposedSets < 0) {\r\n    warning = 'Sets cannot be negative';\r\n  } else if (proposedSets > landmarks.MRV) {\r\n    warning = `Above MRV (${landmarks.MRV}). Consider deload.`;\r\n  } else if (proposedSets < landmarks.MV) {\r\n    warning = `Below MV (${landmarks.MV}). May not be sufficient for adaptation.`;\r\n  }\r\n  \r\n  return {\r\n    isValid,\r\n    warning,\r\n    proposedSets,\r\n    landmarks\r\n  };\r\n}\r\n\r\n/**\r\n * Get volume progression recommendation for next week\r\n * @param {string} muscle - Muscle group name\r\n * @param {Object} feedback - Latest training feedback\r\n * @returns {Object} - Next week recommendation\r\n */\r\nfunction getVolumeProgression(muscle, feedback) {\r\n  const currentSets = trainingState.currentWeekSets[muscle];\r\n  const volumeAnalysis = analyzeVolumeStatus(muscle);\r\n  \r\n  // Get stimulus score\r\n  const stimulusResult = scoreStimulus(feedback.stimulus);\r\n  \r\n  // Get set progression recommendation\r\n  const progressionResult = setProgressionAlgorithm(feedback.soreness, feedback.performance);\r\n  \r\n  // Combine recommendations with volume constraints\r\n  let finalSetChange = progressionResult.setChange;\r\n  let finalAdvice = progressionResult.advice;\r\n  \r\n  // Override if at volume limits\r\n  if (volumeAnalysis.status === 'maximum' && finalSetChange > 0) {\r\n    finalSetChange = 0;\r\n    finalAdvice = \"At MRV limit. Hold sets or consider deload.\";\r\n  }\r\n  \r\n  if (volumeAnalysis.status === 'under-minimum' && finalSetChange <= 0) {\r\n    finalSetChange = 2;\r\n    finalAdvice = \"Below minimum volume. Add sets regardless of fatigue.\";\r\n  }\r\n  \r\n  // Special handling for recovery sessions\r\n  if (progressionResult.action === 'recovery') {\r\n    const recoveryVolume = calculateRecoveryVolume(muscle, feedback.hasIllness);\r\n    finalSetChange = recoveryVolume.recommendedSets - currentSets;\r\n    finalAdvice = `Recovery session: ${recoveryVolume.recommendedSets} sets (${recoveryVolume.reasoning})`;\r\n  }\r\n  \r\n  const projectedSets = Math.max(0, currentSets + finalSetChange);\r\n  \r\n  return {\r\n    muscle,\r\n    currentSets,\r\n    projectedSets,\r\n    setChange: finalSetChange,\r\n    advice: finalAdvice,\r\n    stimulusScore: stimulusResult.score,\r\n    volumeStatus: volumeAnalysis.status,\r\n    targetRIR: trainingState.getTargetRIR(),\r\n    deloadRecommended: trainingState.shouldDeload()\r\n  };\r\n}\r\n\r\n/**\r\n * Analyze all muscles for deload necessity\r\n * @returns {Object} - Deload analysis\r\n */\r\nfunction analyzeDeloadNeed() {\r\n  const muscles = Object.keys(trainingState.volumeLandmarks);\r\n  const mrvBreaches = muscles.filter(muscle => \r\n    trainingState.getVolumeStatus(muscle) === 'maximum'\r\n  );\r\n  \r\n  const shouldDeload = trainingState.shouldDeload();\r\n  const reasons = [];\r\n  \r\n  if (trainingState.consecutiveMRVWeeks >= 2) {\r\n    reasons.push('Two consecutive weeks at MRV');\r\n  }\r\n  \r\n  if (trainingState.totalMusclesNeedingRecovery >= Math.ceil(muscles.length / 2)) {\r\n    reasons.push('Most muscles need recovery sessions');\r\n  }\r\n  \r\n  if (trainingState.weekNo >= trainingState.mesoLen) {\r\n    reasons.push('End of mesocycle reached');\r\n  }\r\n  \r\n  if (mrvBreaches.length >= Math.ceil(muscles.length / 3)) {\r\n    reasons.push(`${mrvBreaches.length} muscle groups at/above MRV`);\r\n  }\r\n  \r\n  return {\r\n    shouldDeload,\r\n    reasons,\r\n    mrvBreaches,\r\n    consecutiveMRVWeeks: trainingState.consecutiveMRVWeeks,\r\n    currentWeek: trainingState.weekNo,\r\n    mesoLength: trainingState.mesoLen,\r\n    musclesNeedingRecovery: trainingState.totalMusclesNeedingRecovery\r\n  };\r\n}\r\n\r\n// Export all functions\r\nexport {\r\n  scoreStimulus,\r\n  scoreStimulus as mevStimulusEstimator,\r\n  setProgressionAlgorithm,\r\n  setProgressionAlgorithm as rpSetProgression,\r\n  analyzeVolumeStatus,\r\n  calculateRecoveryVolume,\r\n  validateVolumeInput,\r\n  getVolumeProgression,\r\n  analyzeDeloadNeed,\r\n  autoSetIncrement,\r\n  processWeeklyVolumeProgression\r\n};\r\n","/**\r\n * Renaissance Periodization Fatigue Management\r\n * Handles recovery monitoring, frequency optimization, and fatigue accumulation\r\n */\r\n\r\nimport trainingState from '../core/trainingState.js';\r\n\r\n/**\r\n * Analyze recovery status and frequency optimization\r\n * @param {number} sorenessRecoveryDays - Days until soreness is gone\r\n * @param {number} currentSessionGap - Days between sessions for this muscle\r\n * @param {string} muscle - Muscle group name\r\n * @returns {Object} - Frequency analysis\r\n */\r\nfunction analyzeFrequency(sorenessRecoveryDays, currentSessionGap, muscle = null) {\r\n  const recoveryTime = Math.max(0, sorenessRecoveryDays);\r\n  const sessionGap = Math.max(1, currentSessionGap);\r\n  \r\n  let recommendation = '';\r\n  let action = '';\r\n  let urgency = 'normal';\r\n  let frequencyAdjustment = 0;\r\n  \r\n  // Recovery vs session gap analysis\r\n  const recoveryRatio = recoveryTime / sessionGap;\r\n  \r\n  if (recoveryRatio < 0.7) {\r\n    // Recovering much faster than session frequency\r\n    recommendation = 'You heal early → Add one session per week';\r\n    action = 'increase_frequency';\r\n    frequencyAdjustment = 1;\r\n    urgency = 'medium';\r\n  } else if (recoveryRatio > 1.3) {\r\n    // Still sore when next session is due\r\n    recommendation = 'Recovery lags → Insert an extra rest day';\r\n    action = 'decrease_frequency';\r\n    frequencyAdjustment = -1;\r\n    urgency = 'high';\r\n  } else {\r\n    // Optimal recovery timing\r\n    recommendation = 'Frequency is optimal';\r\n    action = 'maintain';\r\n    frequencyAdjustment = 0;\r\n    urgency = 'normal';\r\n  }\r\n  \r\n  // Consider current volume when making frequency recommendations\r\n  if (muscle) {\r\n    const volumeStatus = trainingState.getVolumeStatus(muscle);\r\n    \r\n    if (volumeStatus === 'maximum' && action === 'increase_frequency') {\r\n      recommendation = 'At MRV - maintain frequency despite early recovery';\r\n      action = 'maintain';\r\n      frequencyAdjustment = 0;\r\n    }\r\n    \r\n    if (volumeStatus === 'under-minimum' && action === 'decrease_frequency') {\r\n      recommendation = 'Below MV - consider recovery methods instead of reducing frequency';\r\n      action = 'improve_recovery';\r\n      frequencyAdjustment = 0;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    sorenessRecoveryDays: recoveryTime,\r\n    currentSessionGap: sessionGap,\r\n    recoveryRatio: Math.round(recoveryRatio * 100) / 100,\r\n    recommendation,\r\n    action,\r\n    frequencyAdjustment,\r\n    urgency,\r\n    muscle\r\n  };\r\n}\r\n\r\n/**\r\n * Assess overall fatigue accumulation\r\n * @param {Object} weeklyData - Weekly fatigue metrics\r\n * @returns {Object} - Fatigue assessment\r\n */\r\nfunction assessFatigueAccumulation(weeklyData) {\r\n  const {\r\n    averageSoreness = 1,\r\n    sleepQuality = 7, // 1-10 scale\r\n    stressLevel = 5, // 1-10 scale  \r\n    musclesNeedingRecovery = 0,\r\n    consecutiveMRVWeeks = 0,\r\n    performanceDecline = false\r\n  } = weeklyData;\r\n  \r\n  // Calculate fatigue score (0-100)\r\n  let fatigueScore = 0;\r\n  \r\n  // Soreness contribution (0-30 points)\r\n  fatigueScore += Math.min(30, (averageSoreness / 3) * 30);\r\n  \r\n  // Sleep quality contribution (0-20 points, inverted)\r\n  fatigueScore += Math.max(0, 20 - (sleepQuality / 10) * 20);\r\n  \r\n  // Stress level contribution (0-20 points)\r\n  fatigueScore += (stressLevel / 10) * 20;\r\n  \r\n  // Volume overreaching contribution (0-20 points)\r\n  const volumeOverreach = Math.min(20, (musclesNeedingRecovery / 12) * 20);\r\n  fatigueScore += volumeOverreach;\r\n  \r\n  // Consecutive MRV weeks (0-10 points)\r\n  fatigueScore += Math.min(10, consecutiveMRVWeeks * 5);\r\n  \r\n  // Performance decline bonus\r\n  if (performanceDecline) {\r\n    fatigueScore += 10;\r\n  }\r\n  \r\n  // Determine fatigue level\r\n  let fatigueLevel = '';\r\n  let recommendations = [];\r\n  let deloadUrgency = 'none';\r\n  \r\n  if (fatigueScore <= 25) {\r\n    fatigueLevel = 'low';\r\n    recommendations.push('Continue current program');\r\n    recommendations.push('Consider volume progression opportunities');\r\n  } else if (fatigueScore <= 50) {\r\n    fatigueLevel = 'moderate';\r\n    recommendations.push('Monitor recovery closely');\r\n    recommendations.push('Ensure adequate sleep and nutrition');\r\n    deloadUrgency = 'low';\r\n  } else if (fatigueScore <= 75) {\r\n    fatigueLevel = 'high';\r\n    recommendations.push('Reduce training stress');\r\n    recommendations.push('Consider recovery week');\r\n    recommendations.push('Prioritize sleep and stress management');\r\n    deloadUrgency = 'medium';\r\n  } else {\r\n    fatigueLevel = 'excessive';\r\n    recommendations.push('Implement deload immediately');\r\n    recommendations.push('Address sleep and lifestyle factors');\r\n    recommendations.push('Consider extending deload period');\r\n    deloadUrgency = 'high';\r\n  }\r\n  \r\n  return {\r\n    fatigueScore: Math.round(fatigueScore),\r\n    fatigueLevel,\r\n    recommendations,\r\n    deloadUrgency,\r\n    breakdown: {\r\n      soreness: Math.min(30, (averageSoreness / 3) * 30),\r\n      sleep: Math.max(0, 20 - (sleepQuality / 10) * 20),\r\n      stress: (stressLevel / 10) * 20,\r\n      volume: volumeOverreach,\r\n      consecutive: Math.min(10, consecutiveMRVWeeks * 5),\r\n      performance: performanceDecline ? 10 : 0\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Generate recovery session recommendations\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} options - Recovery options\r\n * @returns {Object} - Recovery session plan\r\n */\r\nfunction generateRecoverySession(muscle, options = {}) {\r\n  const {\r\n    hasIllness = false,\r\n    sorenessLevel = 2,\r\n    lastSessionRIR = 0,\r\n    preferredRecoveryType = 'volume'\r\n  } = options;\r\n  \r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  const baseRecoveryVolume = trainingState.getRecoveryVolume(muscle, hasIllness);\r\n  \r\n  let recoveryPlan = {\r\n    muscle,\r\n    type: preferredRecoveryType,\r\n    sets: baseRecoveryVolume,\r\n    intensity: '60-70% of normal',\r\n    rirTarget: '3-4 RIR',\r\n    duration: '1 session',\r\n    notes: []\r\n  };\r\n  \r\n  // Adjust based on soreness level\r\n  if (sorenessLevel >= 3) {\r\n    recoveryPlan.sets = Math.round(baseRecoveryVolume * 0.7);\r\n    recoveryPlan.intensity = '50-60% of normal';\r\n    recoveryPlan.rirTarget = '4-5 RIR';\r\n    recoveryPlan.notes.push('High soreness - very light session');\r\n  }\r\n  \r\n  // Adjust for illness\r\n  if (hasIllness) {\r\n    recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\r\n    recoveryPlan.intensity = '40-50% of normal';\r\n    recoveryPlan.notes.push('Illness present - prioritize rest');\r\n  }\r\n  \r\n  // Adjust based on last session intensity\r\n  if (lastSessionRIR <= 0.5) {\r\n    recoveryPlan.sets = Math.round(recoveryPlan.sets * 0.8);\r\n    recoveryPlan.notes.push('Last session was very intense');\r\n  }\r\n  \r\n  // Recovery type specific adjustments\r\n  if (preferredRecoveryType === 'deload') {\r\n    recoveryPlan.sets = Math.round(landmarks.MEV * 0.5);\r\n    recoveryPlan.intensity = '40-50% of normal';\r\n    recoveryPlan.duration = '3-7 days';\r\n    recoveryPlan.notes.push('Full deload protocol');\r\n  }\r\n  \r\n  return recoveryPlan;\r\n}\r\n\r\n/**\r\n * Monitor overreaching vs overtraining risk\r\n * @param {Object} metrics - Training metrics over time\r\n * @returns {Object} - Risk assessment\r\n */\r\nfunction assessOverreachingRisk(metrics) {\r\n  const {\r\n    weeklyPerformanceTrend = [], // Array of performance scores\r\n    weeklyFatigueTrend = [], // Array of fatigue scores\r\n    volumeProgression = [], // Array of weekly volumes\r\n    motivationLevel = 5, // 1-10\r\n    injuryRisk = 1 // 1-10\r\n  } = metrics;\r\n  \r\n  let riskScore = 0;\r\n  let riskFactors = [];\r\n  \r\n  // Performance trend analysis\r\n  if (weeklyPerformanceTrend.length >= 2) {\r\n    const recentTrend = weeklyPerformanceTrend.slice(-3);\r\n    const isDecreasing = recentTrend.every((val, i) => \r\n      i === 0 || val <= recentTrend[i - 1]\r\n    );\r\n    \r\n    if (isDecreasing) {\r\n      riskScore += 20;\r\n      riskFactors.push('Consistent performance decline');\r\n    }\r\n  }\r\n  \r\n  // Fatigue accumulation\r\n  if (weeklyFatigueTrend.length >= 2) {\r\n    const avgFatigue = weeklyFatigueTrend.reduce((a, b) => a + b, 0) / weeklyFatigueTrend.length;\r\n    if (avgFatigue > 60) {\r\n      riskScore += 25;\r\n      riskFactors.push('High average fatigue');\r\n    }\r\n  }\r\n  \r\n  // Volume progression rate\r\n  if (volumeProgression.length >= 3) {\r\n    const volumeIncrease = volumeProgression[volumeProgression.length - 1] - volumeProgression[0];\r\n    const weekSpan = volumeProgression.length;\r\n    const weeklyIncrease = volumeIncrease / weekSpan;\r\n    \r\n    if (weeklyIncrease > 2) {\r\n      riskScore += 15;\r\n      riskFactors.push('Rapid volume progression');\r\n    }\r\n  }\r\n  \r\n  // Motivation and wellbeing\r\n  if (motivationLevel <= 3) {\r\n    riskScore += 15;\r\n    riskFactors.push('Low motivation/enjoyment');\r\n  }\r\n  \r\n  // Injury risk\r\n  if (injuryRisk >= 7) {\r\n    riskScore += 15;\r\n    riskFactors.push('High injury risk indicators');\r\n  }\r\n  \r\n  // Current training state\r\n  if (trainingState.consecutiveMRVWeeks >= 2) {\r\n    riskScore += 10;\r\n    riskFactors.push('Consecutive weeks at MRV');\r\n  }\r\n  \r\n  // Determine risk level\r\n  let riskLevel = '';\r\n  let recommendations = [];\r\n  \r\n  if (riskScore <= 20) {\r\n    riskLevel = 'low';\r\n    recommendations.push('Continue progressive overload');\r\n    recommendations.push('Monitor for early warning signs');\r\n  } else if (riskScore <= 40) {\r\n    riskLevel = 'moderate';\r\n    recommendations.push('Slow progression rate');\r\n    recommendations.push('Increase recovery focus');\r\n    recommendations.push('Consider planned deload');\r\n  } else if (riskScore <= 70) {\r\n    riskLevel = 'high';\r\n    recommendations.push('Implement deload week');\r\n    recommendations.push('Address lifestyle stressors');\r\n    recommendations.push('Reduce training frequency');\r\n  } else {\r\n    riskLevel = 'critical';\r\n    recommendations.push('Stop training temporarily');\r\n    recommendations.push('Focus on full recovery');\r\n    recommendations.push('Consult with coach/healthcare provider');\r\n  }\r\n  \r\n  return {\r\n    riskScore,\r\n    riskLevel,\r\n    riskFactors,\r\n    recommendations,\r\n    requiresImmediateAction: riskScore > 60\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate optimal session frequency for a muscle\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} constraints - Training constraints\r\n * @returns {Object} - Frequency recommendation\r\n */\r\nfunction calculateOptimalFrequency(muscle, constraints = {}) {\r\n  const {\r\n    availableDays = 6,\r\n    currentVolume = null,\r\n    recoveryCapacity = 'normal', // low, normal, high\r\n    trainingAge = 'intermediate' // beginner, intermediate, advanced\r\n  } = constraints;\r\n  \r\n  const volume = currentVolume || trainingState.currentWeekSets[muscle];\r\n  const landmarks = trainingState.volumeLandmarks[muscle];\r\n  \r\n  // Base frequency recommendations by training age\r\n  const baseFrequencies = {\r\n    beginner: { min: 2, max: 3 },\r\n    intermediate: { min: 2, max: 4 },\r\n    advanced: { min: 3, max: 5 }\r\n  };\r\n  \r\n  const ageRecommendation = baseFrequencies[trainingAge];\r\n  \r\n  // Adjust for volume\r\n  let volumeFrequency = 2;\r\n  if (volume >= landmarks.MAV) {\r\n    volumeFrequency = Math.min(4, Math.ceil(volume / 6)); // ~6 sets per session max at high volumes\r\n  } else if (volume >= landmarks.MEV) {\r\n    volumeFrequency = Math.min(3, Math.ceil(volume / 8)); // ~8 sets per session\r\n  } else {\r\n    volumeFrequency = Math.max(2, Math.ceil(volume / 10)); // ~10 sets per session at lower volumes\r\n  }\r\n  \r\n  // Adjust for recovery capacity\r\n  const recoveryMultipliers = {\r\n    low: 0.8,\r\n    normal: 1.0,\r\n    high: 1.2\r\n  };\r\n  \r\n  const adjustedFrequency = Math.round(volumeFrequency * recoveryMultipliers[recoveryCapacity]);\r\n  \r\n  // Constrain to available days and training age limits\r\n  const recommendedFrequency = Math.max(\r\n    ageRecommendation.min,\r\n    Math.min(ageRecommendation.max, adjustedFrequency, availableDays)\r\n  );\r\n  \r\n  // Calculate sets per session\r\n  const setsPerSession = Math.ceil(volume / recommendedFrequency);\r\n  \r\n  return {\r\n    muscle,\r\n    recommendedFrequency,\r\n    setsPerSession,\r\n    totalVolume: volume,\r\n    reasoning: [\r\n      `${volume} weekly sets`,\r\n      `${recoveryCapacity} recovery capacity`,\r\n      `${trainingAge} training age`,\r\n      `${availableDays} available days`\r\n    ],\r\n    alternatives: {\r\n      conservative: Math.max(2, recommendedFrequency - 1),\r\n      aggressive: Math.min(availableDays, recommendedFrequency + 1)\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Enhanced fatigue detection using SFR and rep strength drop\r\n * @param {string} muscle - Muscle group\r\n * @param {Object} feedback - Feedback data with soreness, jointAche, perfChange, stimulus, lastLoad\r\n * @param {Object} state - Training state singleton\r\n * @returns {boolean} - True if high fatigue detected\r\n */\r\nfunction isHighFatigue(muscle, feedback, state) {\r\n  // Calculate total fatigue score\r\n  const soreness = feedback.soreness || 0;\r\n  const jointAche = feedback.jointAche || 0;\r\n  const perfChange = feedback.perfChange || 0;\r\n  \r\n  // Fatigue components: soreness + joint ache + performance decline penalty\r\n  const fatigue = soreness + jointAche + (perfChange < 0 ? 2 : 0);\r\n  \r\n  // Stimulus components: pump + disruption (mind-muscle connection less relevant for fatigue)\r\n  const stimulus = (feedback.pump || 0) + (feedback.disruption || 0);\r\n  \r\n  // Calculate Stimulus-to-Fatigue Ratio (SFR)\r\n  const SFR = stimulus / (fatigue || 1); // Avoid zero division\r\n  \r\n  // Check for rep strength drop\r\n  const strengthDrop = feedback.lastLoad ? state.repStrengthDrop(muscle, feedback.lastLoad) : false;\r\n  \r\n  // High fatigue if SFR ≤ 1 OR strength drop detected\r\n  return (SFR <= 1) || strengthDrop;\r\n}\r\n\r\nexport {\r\n  analyzeFrequency,\r\n  calculateOptimalFrequency,\r\n  isHighFatigue\r\n};\r\n"],"names":["modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","defineInteropFlag","export","scoreStimulus","setProgressionAlgorithm","analyzeVolumeStatus","calculateRecoveryVolume","validateVolumeInput","getVolumeProgression","analyzeDeloadNeed","autoSetIncrement","processWeeklyVolumeProgression","_trainingStateJs","_trainingStateJsDefault","interopDefault","_fatigueJs","mmc","pump","disruption","advice","action","setChange","clamp","val","min","max","Math","clampedMmc","clampedPump","clampedDisruption","totalScore","score","breakdown","muscle","feedback","state","MEV","MRV","volumeLandmarks","currentSets","currentWeekSets","atMEV","atMRV","lowStimulus","stimulus","goodRecovery","soreness","perf","recoverySession","add","delta","reason","baseDelta","weeklyFeedback","progressionLog","deloadTriggered","mrvHits","keys","forEach","isHighFatigue","hitMRV","console","log","increment","addSets","getWeeklySets","previousSets","lastWeekSets","status","getVolumeStatus","shouldDeload","startDeload","weekComplete","recommendation","performance","s","p","progressionMatrix","sets","default","landmarks","percentage","urgency","MV","MAV","round","color","getVolumeColor","hasIllness","recoveryVolume","getRecoveryVolume","recommendedSets","reasoning","proposedSets","isValid","warning","volumeAnalysis","stimulusResult","progressionResult","finalSetChange","finalAdvice","projectedSets","stimulusScore","volumeStatus","targetRIR","getTargetRIR","deloadRecommended","muscles","mrvBreaches","filter","reasons","consecutiveMRVWeeks","push","totalMusclesNeedingRecovery","ceil","weekNo","mesoLen","currentWeek","mesoLength","musclesNeedingRecovery","analyzeFrequency","calculateOptimalFrequency","sorenessRecoveryDays","currentSessionGap","recoveryTime","sessionGap","frequencyAdjustment","recoveryRatio","constraints","availableDays","currentVolume","recoveryCapacity","trainingAge","volume","ageRecommendation","baseFrequencies","beginner","intermediate","advanced","volumeFrequency","adjustedFrequency","recoveryMultipliers","low","normal","high","recommendedFrequency","setsPerSession","totalVolume","alternatives","conservative","aggressive","jointAche","perfChange","strengthDrop","lastLoad","repStrengthDrop","SFR","fatigue"],"version":3,"file":"volume.43331bd9.js.map"}